"""
A directive used by the Apollo iOS client to annotate operations or fragments that should be used exclusively for generating local cache mutations instead of as standard operations.
"""
directive @apollo_client_ios_localCacheMutation on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

enum ActionType {
  DECREASE
  INCREASE
}

enum ActivityLevel {
  EXERCISE_1
  EXERCISE_1_2
  EXERCISE_2
  EXERCISE_3_MORE
  NOT_ACTIVE
}

type ActivityLog implements Node {
  appUser: ProfileType
  createdAt: DateTime!
  eventName: String!
  id: ID!
  payload: GenericScalar
  userEmail: String
  userName: String
}

type ActivityLogConnection {
  edges: [ActivityLogEdge]!
  pageInfo: PageInfo!
}

type ActivityLogEdge {
  cursor: String!
  node: ActivityLog
}

type AddBiomarker {
  biomarker: Biomarker
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input AddBiomarkerInput {
  aliases: [BiomarkerAliasInput!]
  borderlineRange: BiomarkerRangeInput
  category: ID!
  description: String
  isVisible: Boolean = true
  method: String
  name: String!
  normalValues: [GenericScalar!] = ["{}"]
  optimalRange: BiomarkerRangeInput
  order: Int = 0
  range: BiomarkerRangeInput
  units: [ID!]!
}

type AddBiomarkerResults {
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input AddBiomarkerResultsInput {
  biomarkers: [BiomarkerResultInput!]!
  labTestReportId: ID!
}

type AddExerciseEntry {
  message: String!
  success: Boolean!
}

type AddFavoriteArticle {
  message: String!
  success: Boolean!
}

type AddFoodLog {
  foodLog: FoodLog
  message: String!
  success: Boolean!
}

type AddGPTFoodLog {
  message: String!
  success: Boolean!
}

input AddGPTFoodLogInput {
  id: ID!
  mealTime: MealTime!
  recipeName: String!
}

type AddHRVLog {
  message: String!
  success: Boolean!
}

type AddHeartRateLog {
  message: String!
  success: Boolean!
}

type AddRecipesToShoppingList {
  message: String
  success: Boolean
}

type AddSleepQualityScore {
  message: String!
  success: Boolean!
}

type AddSleepTime {
  message: String!
  success: Boolean!
}

type AddStepsCount {
  message: String!
  success: Boolean!
}

type AddToShoppingList {
  message: String
  success: Boolean
}

type Adherence {
  color: AdherenceColor
  icon: Icon
  isRecommended: Boolean
  reason: String
  score: Float
  title: String
}

enum AdherenceColor {
  BLUE
  GREEN
  GREY
  RED
  YELLOW
}

type Aggregate implements Node {
  aggregateMeta: AggregateMeta
  aisleName: String
  comment: String
  createdAt: DateTime!
  databaseId: String
  grams: Float
  id: ID!
  ingredient: String
  isCleared: Boolean!
  isDone: Boolean!
  listitemSet(after: String, before: String, first: Int, last: Int, offset: Int, recipe: ID): ListItemConnection!
  meta: JSONString!
  profile: ProfileType!
  quantity: Int
  servingEquivalent: Float
  unit: String
  updatedAt: DateTime!
}

type AggregateConnection {
  edges: [AggregateEdge]!
  pageInfo: PageInfo!
}

type AggregateEdge {
  cursor: String!
  node: Aggregate
}

type AggregateMeta {
  aisle: String
  grams: Float @deprecated(reason: "Not used, will be removed")
  ids: [String]
  idsContribution: [Contribution]
  name: String
  qty: Int
  rawQty: Float
}

enum AlertAction {
  ATTEMPTED
  CONTACTED
}

enum AlertStatus {
  COMPLETED
  FOLLOW_UP
  IN_REVIEW
  NO_FOLLOW_UP
  OTHER
  OUT_OF_RANGE
  REVIEWED
}

type Answer {
  answer: String
  id: ID
  imageUrl: String
  selected: Boolean
  type: HabitAnswerType!
}

type AnswerCounter {
  answer: Answer!
  total: Int!
}

type AppRestriction {
  feature: String!
  limitations: [Limitation!]!
}

input AppUserActivityLogFiltersInput {
  eventName: String
  profileId: ID
}

type Appointment {
  appointmentType: AppointmentType!
  attendees: [Attendee!]!
  contactType: CalendarContactType!
  description: String
  end: DateTime!
  id: ID!
  meetingUrl: String
  sendbirdRoomId: String @deprecated(reason: "Soon it will be removed")
  start: DateTime!
  status: EventStatus!
  title: String!
  zoomSessionName: String
  zoomSessionPassword: String
}

type AppointmentCredit {
  appointmentType: AppointmentType!
  id: ID!
  labTestReports(after: String, before: String, first: Int, last: Int): LabTestReportConnection
  value: Int!
}

type AppointmentCredits {
  credits: [AppointmentCredit!]!
}

enum AppointmentMultiCoachType {
  ANY_COACH_AVAILABLE
  COLLECTIVE
  INDIVIDUAL
}

type AppointmentType implements Node {
  contactType: [String!]!
  durationMin: Int!
  id: ID!
  multiCoachType: AppointmentMultiCoachType!
  numberOfMember: Int!
  refundableBeforeHours: Int!
  title: String!
}

type AppointmentTypeConnection {
  edges: [AppointmentTypeEdge]!
  pageInfo: PageInfo!
}

type AppointmentTypeEdge {
  cursor: String!
  node: AppointmentType
}

type ArticleRecommended implements Node {
  article: ContentLibraryType!
  biomarker: Biomarker!
  createdAt: DateTime!
  id: ID!
  normalValues: [GenericScalar!]
  updatedAt: DateTime!
  valueMax: Float
  valueMin: Float
}

type ArticleRecommendedConnection {
  edges: [ArticleRecommendedEdge]!
  pageInfo: PageInfo!
}

type ArticleRecommendedEdge {
  cursor: String!
  node: ArticleRecommended
}

type Assessment implements Node {
  assessmentType: AssessmentType!
  createdAt: DateTime!
  description: String
  finalQuestion: AssessmentQuestion
  icon: String
  id: ID!
  initialQuestion: AssessmentQuestion
  interval: Int
  isDraft: Boolean!
  isPublic: Boolean!
  order: Int!
  progressBar: Boolean!
  questions(after: String, before: String, first: Int, last: Int, offset: Int): AssessmentQuestionConnection
  score: Float
  status: AssessmentStatus
  title: String!
  updatedAt: DateTime!
  weight: Int
}

type AssessmentAnswer implements Node {
  attribute: GenericScalar
  createdAt: DateTime!
  id: ID!
  isCorrect: Boolean!
  isSelected: Boolean
  nextQuestion: AssessmentQuestion
  score: Int
  text: String!
  updatedAt: DateTime!
}

type AssessmentConnection {
  edges: [AssessmentEdge]!
  pageInfo: PageInfo!
}

type AssessmentEdge {
  cursor: String!
  node: Assessment
}

type AssessmentQuestion implements Node {
  answerText: String
  answers: [AssessmentAnswer!]
  assessment: Assessment
  canSkip: Boolean!
  createdAt: DateTime!
  helpText: String
  id: ID!
  information: String
  isFinalQuestion: Boolean!
  isInitialQuestion: Boolean!
  nextQuestion: AssessmentQuestion
  profileField: QuestionProfileField
  questionType: QuestionType!
  text: String!
  updatedAt: DateTime!
}

type AssessmentQuestionConnection {
  edges: [AssessmentQuestionEdge]!
  pageInfo: PageInfo!
}

type AssessmentQuestionEdge {
  cursor: String!
  node: AssessmentQuestion
}

enum AssessmentStatus {
  DONE
  IN_PROGRESS
  NEEDS_UPDATE
  TODO
}

enum AssessmentType {
  COMMON
  DIET_ID
  ON_BOARDING
}

input AssessmentsFilterInput {
  description: String
  isDraft: Boolean
  isPublic: Boolean
  title: String
}

type AssistantIngredient {
  grams: Float
  name: String
  quantity: Int
  unit: String
}

type Attendee {
  displayName: String
  email: String!
  status: EventParticipationStatus!
}

enum AttrDataType {
  BOOLEAN
  FLOAT
  INT
  STRING
}

input AttributeInput {
  dataType: AttrDataType!
  name: String!
  value: GenericScalar
}

union AvailableChecklistItems = ChecklistItem | MyChecklistItemOnPlan | SupplementOnPlan

enum BiologicalSex {
  FEMALE
  MALE
  PREFER_NOT_TO_DISCLOSE
  UNCERTAIN
  UNKNOWN
}

type Biomarker {
  aliases: [BiomarkerAlias!]
  borderlineRange: BiomarkerRange
  category: BiomarkerCategory!
  createdAt: DateTime!
  description: String
  id: ID!
  method: String
  name: String!
  normalStringValues: JSONString
  normalValues: [GenericScalar!]
  optimalRange: BiomarkerRange
  range: BiomarkerRange
  units: [BiomarkerUnit!]!
  updatedAt: DateTime!
}

type BiomarkerAlias {
  language: String!
  name: String!
}

input BiomarkerAliasInput {
  language: BiomarkerLanguage!
  name: String!
}

type BiomarkerCategory implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  parent: BiomarkerCategory
  updatedAt: DateTime!
}

type BiomarkerCategoryConnection {
  edges: [BiomarkerCategoryEdge]!
  pageInfo: PageInfo!
}

type BiomarkerCategoryEdge {
  cursor: String!
  node: BiomarkerCategory
}

type BiomarkerConnection {
  edges: [BiomarkerEdge]!
  pageInfo: PageInfo!
}

type BiomarkerEdge {
  cursor: String!
  node: Biomarker
}

input BiomarkerFilterInput {
  categoryId: ID
  name: String
}

enum BiomarkerIntervalRange {
  ALL
  IN_OPTIMAL_RANGE
  IN_RANGE
  OUT_RANGE
}

enum BiomarkerLanguage {
  AFRIKAANS
  ALBANIAN
  ARABIC
  CATALAN
  CHINESE
  CROATIAN
  CZECH
  DANISH
  DUTCH
  ENGLISH
  ESTONIAN
  FRENCH
  GERMAN
  HEBREW
  HINDI
  INDONESIAN
  ITALIAN
  JAPANESE
  KOREAN
  POLISH
  PORTUGUESE
  ROMANIAN
  RUSSIAN
  SERBIAN
  SPANISH
  SWEDISH
  THAI
  TURKISH
  UKRAINIAN
  VIETNAMESE
  ZULU
}

type BiomarkerRange {
  max: Float!
  min: Float!
}

input BiomarkerRangeInput {
  max: Float!
  min: Float!
}

input BiomarkerResultInput {
  alert: Boolean
  alertText: String
  biomarkerId: ID!
  biomarkerUnitId: ID!
  date: DateTime!
  result: BiomarkerValueInput!
}

input BiomarkerResultsFilterInput {
  biomarkerId: ID
  biomarkerName: String
  categoryId: ID
  intervalRange: BiomarkerIntervalRange
}

type BiomarkerUnit implements Node {
  alias: String
  createdAt: DateTime!
  factor: Float!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type BiomarkerUnitConnection {
  edges: [BiomarkerUnitEdge]!
  pageInfo: PageInfo!
}

type BiomarkerUnitEdge {
  cursor: String!
  node: BiomarkerUnit
}

enum BiomarkerValueDatatype {
  BOOLEAN
  NUMBER
  STRING
}

input BiomarkerValueInput {
  type: BiomarkerValueDatatype!
  value: GenericScalar!
}

type BrandedFoodConnection {
  count: Int
  edges: [BrandedFoodEdge]!
  pageInfo: PageInfo!
}

type BrandedFoodEdge {
  cursor: String!
  node: BrandedFoodNode
}

type BrandedFoodNode implements Node {
  brandName: String
  brandOwner: String!
  brandedFoodCategory: String
  calories: Float
  dataType: String
  description: String
  foodDataId: String
  gtinUpc: String!
  householdServingFulltext: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  servingSize: Float!
  servingSizeUnit: String!
  tags: [String!]!
}

type BrandedFoodNodeProxy {
  brandedFood: BrandedFoodNode!
}

type BulkCreateEntries {
  message: String!
  success: Boolean!
}

type CPC {
  benefits: String
  description: String
  matchCustomAttribute: Boolean
  name: String
  simpleExamples: [String]
}

type CPCIngredient {
  cpcName: String
  priority: String
  softmax: String
  type: String
}

type CPCIngredientGroup {
  avoid: [CPC]
  decrease: [CPC]
  increase: [CPC]
}

type CPCRule {
  avoid: [CPC]
  decrease: [CPC]
  increase: [CPC]
}

enum CalendarContactType {
  GOOGLE_MEET
  PHONE_CALL
  VIDEO_CALL
  ZOOM
}

type CaloriesPerServing {
  ala: Float
  carbs: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  monounsaturatedFat: Float
  omega3: Float
  polyunsaturatedFat: Float
  protein: Float
  saturatedFat: Float
  transFat: Float
}

type CancelAppointment {
  appointment: Appointment
  message: String!
  success: Boolean!
}

type ChangeMealPlannerDayMeal {
  recipe: Recipe
  success: Boolean
}

type CheckIntake {
  message: String!
  success: Boolean!
}

type CheckItemDirections {
  createdAt: DateTime!
  friday: Boolean!
  id: ID!
  mealTime: TimeOfDay!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  updatedAt: DateTime!
  wednesday: Boolean!
}

type CheckTodayFoodEntry {
  message: String!
  success: Boolean!
}

type CheckTodaySupplementEntry {
  message: String!
  success: Boolean!
}

type Checklist {
  icon: String
  items: [ChecklistItem!]!
  name: String!
}

type ChecklistItem {
  category: String
  checked: Boolean!
  id: ID!
  image: String!
  subtitle: String
  title: String!
}

type CheckoutCreate {
  message: String!
  success: Boolean!
  webUrl: String
}

input CheckoutCreateInput {
  supplementsInCart: [SupplementCartItem!]!
}

type ClearShoppingList {
  success: Boolean
}

type ClearShoppingListCheckedItems {
  success: Boolean
}

type Coach implements Node {
  appointments(end: DateTime, start: DateTime, timezone: String): [Appointment!]!
  avatarUrl: String
  coachTeams(after: String, before: String, first: Int, last: Int, offset: Int): CoachTeamConnection
  coachTypes(after: String, before: String, first: Int, last: Int, offset: Int): CoachTypeConnection
  email: String!
  id: ID!
  irad: String
  irmp: String
  isPrimary: Boolean
  name: String!
  sendbirdId: String
  showAllMembers: Boolean!
}

type CoachConnection {
  edges: [CoachEdge]!
  pageInfo: PageInfo!
}

type CoachEdge {
  cursor: String!
  node: Coach
}

type CoachTeam implements Node {
  coaches: [Coach!]
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type CoachTeamConnection {
  edges: [CoachTeamEdge]!
  pageInfo: PageInfo!
}

type CoachTeamEdge {
  cursor: String!
  node: CoachTeam
}

input CoachTeamsFilterInput {
  name: String
}

type CoachType implements Node {
  coaches: [Coach!]
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type CoachTypeConnection {
  edges: [CoachTypeEdge]!
  pageInfo: PageInfo!
}

type CoachTypeEdge {
  cursor: String!
  node: CoachType
}

input CoachTypesFilterInput {
  mealPlanTemplateId: ID
  name: String
}

type CommonFoodConnection {
  count: Int
  edges: [CommonFoodEdge]!
  pageInfo: PageInfo!
}

type CommonFoodEdge {
  cursor: String!
  node: CommonFoodNode
}

type CommonFoodNode implements Node {
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  portions: [Portion]
  tags: [String!]!
}

type CommonFoodNodeProxy {
  commonFood: CommonFoodNode!
}

type ComponentGoal {
  component: EntryType!
  goal: Int!
}

type ConfirmFoodLogAssistant {
  message: String!
  success: Boolean!
}

input ConfirmFoodLogAssistantInput {
  id: ID!
  mealTime: MealTime!
  text: String!
}

type ConnectedSource {
  createdAt: DateTime!
  currentActive: Boolean!
  id: ID!
  sourceId: Int!
  sourceName: SourceType!
}

type ContentCategoryType implements Node {
  contentLibrary(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection!
  contentlibrarySet(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection! @deprecated(reason: "Not used. Renamed to contentLibrary")
  databaseId: String
  id: ID!
  image: String
  lang: JSONString
  name: String
  order: Int!
  slug: String!
  subcategories: [ContentCategoryType!]
  tags: [ContentTagType!]
}

type ContentCategoryTypeConnection {
  edges: [ContentCategoryTypeEdge]!
  pageInfo: PageInfo!
}

type ContentCategoryTypeEdge {
  cursor: String!
  node: ContentCategoryType
}

input ContentLibraryOrderBy {
  field: ContentLibraryOrderByField!
  order: SortOrder
}

enum ContentLibraryOrderByField {
  created_at
  popularity
}

type ContentLibraryType implements Node {
  categories: [ContentCategoryType]
  createdAt: DateTime
  databaseId: String
  id: ID!
  imageUrl: String
  isBlocked: Boolean!
  isFavorite: Boolean!
  isFeatured: Boolean!
  lang: JSONString!
  order: Int!
  programs: [Program!]
  sourceUrl: String
  subTitle: String
  tags: [ContentTagType!]
  title: String
  updatedAt: DateTime
}

type ContentLibraryTypeConnection {
  edges: [ContentLibraryTypeEdge]!
  pageInfo: PageInfo!
}

type ContentLibraryTypeEdge {
  cursor: String!
  node: ContentLibraryType
}

type ContentTagType implements Node {
  id: ID!
  name: String!
}

type ContentTagTypeConnection {
  edges: [ContentTagTypeEdge]!
  pageInfo: PageInfo!
}

type ContentTagTypeEdge {
  cursor: String!
  node: ContentTagType
}

type Contribution {
  databaseId: String
  eqv: Float
}

input CreateAnswerInput {
  attribute: AttributeInput
  isCorrect: Boolean = false
  nextQuestionId: ID
  score: Int
  text: String!
}

type CreateAppointment {
  appointment: Appointment
  message: String!
  success: Boolean!
}

input CreateAppointmentInput {
  appointmentType: ID!
  coach: ID
  contactType: CalendarContactType
  datetime: DateTime!
  note: String
  timezone: String
}

type CreateArticleRecommended {
  articleRecommended: ArticleRecommended
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateArticleRecommendedInput {
  articleId: ID!
  biomarkerId: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
}

type CreateAssessment {
  assessment: Assessment
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateAssessmentInput {
  assessmentType: AssessmentType = COMMON
  description: String
  icon: Upload
  interval: Int
  isDraft: Boolean = true
  isPublic: Boolean = true
  order: Int = 0
  progressBar: Boolean = true
  title: String!
  weight: Int
}

type CreateBiomarkerCategory {
  biomarkerCategory: BiomarkerCategory
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateBiomarkerCategoryInput {
  name: String!
  parent: ID
}

type CreateCoachTeam {
  coachTeam: CoachTeam
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateCoachTeamInput {
  coaches: [ID!]
  description: String
  name: String!
}

type CreateCoachType {
  coachType: CoachType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateCoachTypeInput {
  coaches: [ID!]
  description: String
  name: String!
}

type CreateContentCategory {
  contentCategory: ContentCategoryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateContentCategoryInput {
  image: Upload
  lang: GenericScalar
  name: String!
  order: Int!
  subcategories: [ID]
  tags: [ID]
}

type CreateContentLibrary {
  contentLibrary: ContentLibraryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateContentLibraryInput {
  categories: [ID]
  imageUrl: String!
  isBlocked: Boolean
  isFeatured: Boolean
  lang: GenericScalar = "{}"
  order: Int
  programs: [ID]
  sourceUrl: String
  subTitle: String
  tags: [ID]
  title: String!
}

type CreateContentTag {
  contentTag: ContentTagType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type CreateDailyRecapAnswer {
  dailyRecapAnswer: DailyRecapAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateDailyRecapAnswerInput {
  answer: String!
  lang: GenericScalar
  type: String!
}

type CreateDailyRecapEntry {
  message: String!
  success: Boolean!
}

type CreateDailyRecapQuestion {
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input CreateDailyRecapQuestionInput {
  answers: [ID]!
  imageUrl: String
  lang: GenericScalar
  program: ID
  question: String!
}

type CreateGooglePlayTransaction {
  message: String
  success: Boolean
}

type CreateLabTestReport {
  message: String!
  report: LabTestReport
  success: Boolean!
}

type CreateMealEntry {
  message: String!
  success: Boolean!
}

type CreateMealLogMutation {
  databaseId: String
  success: Boolean
}

type CreateMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type CreateMyBrandedFood {
  message: String!
  success: Boolean!
}

input CreateMyBrandedFoodInput {
  brandName: String
  brandOwner: String!
  brandedFoodCategory: String
  description: String
  gtinUpc: String!
  householdServingFulltext: String
  name: String!
  nutrients: [NutrientInput!]!
  servingSize: Float!
  servingSizeUnit: String!
}

type CreateMyChecklistItem {
  message: String!
  myChecklistItem: MyChecklistItem
  success: Boolean!
}

type CreateMyChecklistItemLog {
  message: String!
  success: Boolean!
}

type CreateMyCommonFood {
  message: String!
  success: Boolean!
}

input CreateMyCommonFoodInput {
  description: String
  name: String
  nutrients: [NutrientInput]
  portions: [PortionInput!]!
}

type CreateMyRecipe {
  message: String!
  recipe: UserRecipe
  success: Boolean!
}

input CreateMyRecipeInput {
  courses: [String!]!
  cuisines: [String!]!
  ingredientLines: [String!]!
  ingredients: [IngredientAmount!]!
  instructions: [String!]
  language: Language
  mainImage: String
  mealTimes: [MealTime!]!
  name: String!
  numberOfServings: Int!
  squareImage: String
  tags: [String!]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
}

type CreateNote {
  message: String!
  note: Note
  success: Boolean!
}

type CreateOwnMealLogMutation {
  databaseId: String
  message: String
  success: Boolean
}

type CreateOwnRecipe {
  databaseId: String
  success: Boolean
}

type CreateProfileBiomarkers {
  success: Boolean
}

type CreateProfileCustomAttributes {
  errors: [ErrorType]
  success: Boolean
}

type CreateQuestion {
  errors: [FormError!]
  message: String!
  question: AssessmentQuestion
  success: Boolean!
}

input CreateQuestionInput {
  answers: [CreateAnswerInput!]
  assessmentId: ID!
  canSkip: Boolean = false
  helpText: String
  information: String
  isFinalQuestion: Boolean
  isInitialQuestion: Boolean
  nextQuestionId: ID
  profileField: ProfileField
  questionType: QuestionType = SINGLE_SELECT
  text: String!
}

type CreateQuizResult {
  errors: [ErrorType]
  success: Boolean
}

input CreateSPInput {
  coach: ID
  exercise: String
  isActive: Boolean
  name: String!
  nutrition: String
  overview: String
  protocols: [SPProtocolInput!]
  resources: String
  startDate: Date!
  supplements: [SingleSupplementActivableProtocolInput!]
  visibility: Boolean
}

type CreateSupplement {
  message: String!
  success: Boolean!
  supplement: Supplement
}

input CreateSupplementInput {
  brand: String!
  category: String!
  description: String
  directionsOfUse: [DirectionsOfUseInput!]
  directionsOfUseText: String
  externalId: String
  images: [String!]
  ingredients: String
  instructions: String
  mainImage: String!
  name: String!
  servingName: String!
  shopifyParentId: String
  shopifyVariantId: String
  sizeCount: Int
  sku: String
  storeId: String
  supplementFacts: String
}

type CreateSupplementPlan {
  message: String!
  success: Boolean!
  supplementPlan: SupplementPlan
}

type CreateSupplementRecommended {
  errors: [FormError!]
  message: String!
  success: Boolean!
  supplementRecommended: SupplementRecommended
}

input CreateSupplementRecommendedInput {
  biomarkerId: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
  supplementId: ID!
}

type CreateUser {
  message: String!
  success: Boolean!
  user: User
}

type CreateWeightEntry {
  message: String
  success: Boolean
}

type Cuisine implements Node {
  id: ID!
  name: String!
}

type CuisineConnection {
  edges: [CuisineEdge]!
  pageInfo: PageInfo!
}

type CuisineEdge {
  cursor: String!
  node: Cuisine
}

type DailyChecklist {
  days: [DayChecklistItems!]!
  icon: String
  name: String!
}

type DailyExerciseTime {
  totalTime: Int!
  type: String
}

type DailyMoodSummary {
  answersStats: [AnswerCounter!]!
  question: DailyQuestion
}

type DailyQuestion {
  answers: [Answer]
  done: Boolean
  group: GroupQuestion
  id: ID
  imageUrl: String
  isDefault: Boolean!
  question: String
  title: String
}

type DailyRecap {
  date: Date!
  questions: [DailyQuestion!]!
}

type DailyRecapAnswer implements Node {
  answer: String
  id: ID!
  imageUrl: String
  lang: JSONString!
  type: String!
}

type Dashboard {
  components: [EntryType!]!
  goals: [ComponentGoal!]!
}

type DashboardPDFType {
  databaseId: String
  id: ID!
  name: String!
  pdfUrl: String
}

scalar Date

scalar DateTime

type Day {
  closing: String
  description: String
  opening: String
}

type DayChecklistItems {
  date: Date!
  items: [ChecklistItem!]!
}

enum DayStatus {
  EMPTY_DAY
  GOOD_DAY
  PERFECT_DAY
  REGULAR_DAY
}

type DebugMPConditions {
  chocdf: Int
  decrease: [String!]
  distribution: DebugMPMealTimeValues
  fat: Int
  include: [String!]
  increase: [String!]
  maxEnercKcal: Int
  maxIngredientsCount: DebugMPMealTimeValues
  maxNumOfServings: Int
  maxPrepTimeMinutes: DebugMPMealTimeValues
  maxServingWeight: Int
  minServingWeight: Int
  omega3: Int
  procnt: Int
}

type DebugMPMealTimeValues {
  breakfast: Int
  dinner: Int
  lunch: Int
  snack: Int
}

type DebugMealPlanVariables {
  conditions: DebugMPConditions
  format: [String!]
  kcal: Int!
  restrictions: [String!]
  skipIds: [String!]
}

type DeleteArticleRecommended {
  articleRecommended: ArticleRecommended
  message: String!
  success: Boolean!
}

type DeleteAssessment {
  assessment: Assessment
  message: String!
  success: Boolean!
}

type DeleteBiomarkerCategory {
  biomarkerCategory: BiomarkerCategory
  message: String!
  success: Boolean!
}

type DeleteCoachTeam {
  coachTeam: CoachTeam
  message: String!
  success: Boolean!
}

type DeleteCoachType {
  coachType: CoachType
  message: String!
  success: Boolean!
}

type DeleteContentCategory {
  contentCategory: ContentCategoryType
  message: String!
  success: Boolean!
}

type DeleteContentLibrary {
  contentLibrary: ContentLibraryType
  message: String!
  success: Boolean!
}

type DeleteContentTag {
  contentTag: ContentTagType
  message: String!
  success: Boolean!
}

type DeleteDailyRecapAnswer {
  dailyRecapAnswer: DailyRecapAnswer
  message: String!
  success: Boolean!
}

type DeleteDailyRecapEntry {
  message: String!
  success: Boolean!
}

type DeleteDailyRecapQuestion {
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  message: String!
  success: Boolean!
}

type DeleteExerciseEntry {
  message: String!
  success: Boolean!
}

type DeleteFoodLog {
  message: String!
  success: Boolean!
}

type DeleteHRVLog {
  message: String!
  success: Boolean!
}

type DeleteHeartRateLog {
  message: String!
  success: Boolean!
}

type DeleteLabTestReport {
  message: String!
  report: LabTestReport
  success: Boolean!
}

type DeleteMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type DeleteMyBrandedFood {
  message: String!
  success: Boolean!
}

type DeleteMyChecklistItem {
  message: String!
  myChecklistItem: MyChecklistItem
  success: Boolean!
}

type DeleteMyChecklistItemLog {
  message: String!
  success: Boolean!
}

type DeleteMyCommonFood {
  message: String!
  success: Boolean!
}

type DeleteMyRecipe {
  message: String!
  success: Boolean!
}

type DeleteNote {
  message: String!
  note: Note
  success: Boolean!
}

type DeleteQuestion {
  message: String!
  question: AssessmentQuestion
  success: Boolean!
}

type DeleteSleepQualityScore {
  message: String!
  success: Boolean!
}

type DeleteSleepTime {
  message: String!
  success: Boolean!
}

type DeleteStepsCount {
  message: String!
  success: Boolean!
}

type DeleteSupplementRecommended {
  message: String!
  success: Boolean!
  supplementRecommended: SupplementRecommended
}

type DeleteWeightEntry {
  message: String!
  success: Boolean!
}

type Depletion implements Node {
  createdAt: DateTime!
  description: String
  foods: String
  foodsSourceUrl: String
  id: ID!
  ingredient: DrugIngredient
  referenceUrl: String
  restrictions: [Restriction!]
  updatedAt: DateTime!
}

type DepletionConnection {
  edges: [DepletionEdge]!
  pageInfo: PageInfo!
}

type DepletionEdge {
  cursor: String!
  node: Depletion
}

enum DialogCollectionType {
  BOOL
  CHAR
  DATETIME
  INT
}

type DialogType {
  action: String!
  attachment: GenericScalar
  catalog: String!
  collectionType: DialogCollectionType
  databaseId: String
  defaultJump: String!
  deviceAction: String!
  endpoint: String!
  field: String!
  htmlUrl: String
  id: ID!
  jumpFalse: String!
  messages: [String!]
  name: String!
  taskList: TaskListType
  title: String
  type: String!
  uploadedVideo: String
  valueType: DialogValueType
  video: String!
  videoThumbnail: String
}

enum DialogValueType {
  DATE
  DATETIME
  FLOAT
  INTEGER
  NULL
  STRING
}

enum DietaryTag {
  DAIRY_FREE
  GLUTEN_FREE
  PLANT_BASED
  VEGAN
  VEGETARIAN
}

input DirectionsOfUseInput {
  quantity: Float!
  timeOfDay: TimeOfDay!
}

type Drug implements Node {
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type DrugGroup implements Node {
  createdAt: DateTime!
  depletions(after: String, before: String, first: Int, last: Int, offset: Int): DepletionConnection
  drugs: [Drug!]
  id: ID!
  interactions(after: String, before: String, first: Int, last: Int, offset: Int): InteractionConnection
  name: String!
  updatedAt: DateTime!
}

type DrugGroupConnection {
  edges: [DrugGroupEdge]!
  pageInfo: PageInfo!
}

type DrugGroupEdge {
  cursor: String!
  node: DrugGroup
}

type DrugIngredient {
  groups: [String!]
  id: ID!
  name: String!
}

input DrugNutrientInteractionsFilterInput {
  name: String
}

type DuplicateMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type EdamamFoodResult implements Node {
  databaseId: String
  id: ID!
  label: String
  servings: [Servings]
}

type Entry {
  createdAt: DateTime
  date: Date
  source: SourceType
  value: Float
}

enum EntryType {
  DAILY_MOOD
  DAILY_RECAP
  EXERCISE_TRACKER
  FOOD_LOGS
  FOOD_LOG_MEAL_TRACKER
  HEART_RATE_TRACKER
  HRV_TRACKER
  HYDRATION_TRACKER
  MP_MEAL_TRACKER
  MY_CHECKLIST_TRACKER
  PLAN_SUPPLEMENT
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  SLEEP_QUALITY_SCORE_TRACKER
  SLEEP_TIME_TRACKER
  STEPS_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  WEIGHT_TRACKER
}

type ErrorType {
  field: String!
  messages: [String!]!
}

enum EventParticipationStatus {
  ACCEPTED
  DECLINED
  NEEDS_ACTION
  TENTATIVE
  UNKNOWN
}

enum EventStatus {
  CANCELLED
  CONFIRMED
  TENTATIVE
  UNKNOWN
}

enum EventType {
  SESSION
}

type ExerciseEntriesConnection {
  dailyGoal: Int!
  edges: [ExerciseEntryEdge]!
  latestEntry: DateTime
  pageInfo: PageInfo!
  totalTime: Int!
  totalTimePerType: [DailyExerciseTime!]!
}

type ExerciseEntry {
  calories: Int
  createdAt: DateTime!
  datetime: DateTime!
  durationMinutes: Int!
  id: ID!
  intensity: ExerciseIntensity
  source: SourceType
  type: ExerciseType
}

type ExerciseEntryEdge {
  cursor: String!
  node: ExerciseEntry
}

input ExerciseEntryInput {
  datetime: DateTime!
  durationMinutes: PositiveInt!
  intensity: ExerciseIntensity
  source: SourceType
  type: ExerciseType
}

enum ExerciseIntensity {
  LOW
  MODERATE
  VIGOROUS
}

enum ExerciseType {
  BREATHWORK
  CARDIO
  CYCLE
  DANCE
  HIKE
  HOUSEHOLD_CHORES
  IN_BED_EXERCIES
  JOG_OR_RUN
  OTHER
  PHYSICAL_THERAPY_EXERCISES
  PILATES
  RECOVERY
  STRENGTH
  STRETCH
  SWIM
  WALK
  WORKOUT_ROUTINE
  YARD_WORK
  YOGA
}

union Food = BrandedFoodNodeProxy | CommonFoodNodeProxy | MealProxy | MyBrandedFoodProxy | MyCommonFoodProxy | RecipeProxy | UserRecipeProxy

enum FoodCategory {
  BRANDED
  COMMON
  MEAL_PLAN_MEAL
  MY_BRANDED
  MY_COMMON
  RECIPE
  USER_RECIPE
}

input FoodFilter {
  barcode: String
  externalId: String
  id: ID
  ingredients: [String!]
  mealTime: MealTime
  must: [FoodFilter!]
  name: String
  nutrients: [NutrientFilterInput!]
  should: [FoodFilter!]
  tags: [String]
}

type FoodLog {
  date: Date!
  food: Food!
  foodId: ID!
  grams: Float
  id: ID!
  mealTime: MealTime!
  portionModifier: String
  servings: Float
  time: Time
  type: FoodCategory!
}

type FoodLogAssistant {
  id: ID!
  ingredients: [AssistantIngredient]
}

type FoodLogConnection {
  edges: [FoodLogEdge]!
  macros: [MacroNutrientLogged!]!
  pageInfo: PageInfo!
}

type FoodLogEdge {
  cursor: String!
  node: FoodLog
}

type FoodProduct {
  brand: String
  databaseId: String
  displayName: String
  isIncomplete: Boolean
  isVerified: Boolean
  longDesc: String
  mealType: MealType
  name: String
  nutritionalInfo: NutritionalInfo
  serving: Int
  servings: [Servings]
}

type FormError {
  field: String
  messages: [String!]
}

type GenerateMagicLink {
  magicLink: String
  message: String!
  success: Boolean!
}

type GenerateMealPlan {
  mealPlan: [MealPlanDay!]
  message: String
  success: Boolean
}

type GenerateSimpleMealPlan {
  message: String
  success: Boolean
}

input GenerateVideoZoomTokenInput {
  clientMutationId: String
  password: String
  role: VideoZoomRole
  sessionKey: String
  sessionName: String!
  userIdentity: String
}

type GenerateVideoZoomTokenPayload {
  clientMutationId: String
  message: String!
  success: Boolean!
  token: String
}

scalar GenericScalar

input GeoBoundingBox {
  bottomRightLat: Float
  bottomRightLon: Float
  topLeftLat: Float
  topLeftLon: Float
}

type GeoPoint {
  lat: Float
  lon: Float
}

type GooglePlayTransactionType implements Node {
  createdAt: DateTime
  databaseId: String
  id: ID!
  rawData: GenericScalar
}

type GooglePlayTransactionTypeConnection {
  edges: [GooglePlayTransactionTypeEdge]!
  pageInfo: PageInfo!
}

type GooglePlayTransactionTypeEdge {
  cursor: String!
  node: GooglePlayTransactionType
}

enum GroupQuestion {
  MOOD
}

input HRVEntryInput {
  datetime: DateTime!
  source: SourceType!
  value: PositiveFloat!
}

enum HabitAnswerType {
  NEGATIVE
  NEUTRAL
  POSITIVE
}

type HardDeleteMyProfileMutation {
  email: String
  success: Boolean
}

input HeartRateEntryInput {
  datetime: DateTime!
  source: SourceType!
  value: PositiveInt!
}

type HeartRateLog {
  createdAt: DateTime!
  id: ID!
  source: SourceType!
  timestamp: DateTime!
  value: Float!
}

type HeartRateLogs {
  cursor: String!
  node: HeartRateLog
}

type HeartRateLogsConnnection {
  average: Float!
  edges: [HeartRateLogs]!
  latestEntry: DateTime
  maximum: Float!
  minimum: Float!
  pageInfo: PageInfo!
}

input HistoricalBiomarkerResultsFilterInput {
  biomarkerId: ID
  biomarkerName: String
  categoryId: ID
  intervalRange: BiomarkerIntervalRange
  labTestReportId: ID
}

type Hours {
  friday: Day
  monday: Day
  saturday: Day
  sunday: Day
  thursday: Day
  tuesday: Day
  wednesday: Day
}

type HrvLog {
  createdAt: DateTime!
  id: ID!
  source: SourceType!
  timestamp: DateTime!
  value: Float!
}

type HrvLogs {
  cursor: String!
  node: HrvLog
}

type HrvLogsConnnection {
  average: Float!
  edges: [HrvLogs]!
  latestEntry: DateTime
  pageInfo: PageInfo!
}

type Hydration {
  date: Date
  goal: Int
  isToday: Boolean
  quantity: Int
  source: SourceType
}

input HydrationEntryInput {
  date: Date!
  quantity: Float!
  source: SourceType
}

enum Icon {
  ALERT
  CROSS
  UNKNOWN
}

type Ingredient {
  confirmed: Boolean
  cpc: String
  name: String
  priority: Float
  type: String
}

input IngredientAmount {
  foodId: ID!
  grams: Float
  milliliters: Float
}

type IngredientFoodFormat {
  foodId: String!
  grams: Float
  milliliters: Float
  name: String!
}

type IngredientLine {
  comment: String
  ingredient: String
  ingredientLine: String
  other: String
  quantity: String
  unit: String
}

union IngredientSearchResult = EdamamFoodResult

type IngredientSearchResultConnection {
  edges: [IngredientSearchResultEdge]!
  pageInfo: PageInfo!
}

type IngredientSearchResultEdge {
  cursor: String!
  node: IngredientSearchResult
}

input IntValueByMealTime {
  breakfast: Int
  dinner: Int
  lunch: Int
  snack: Int
}

enum IntakeCategory {
  FOOD
  MY_CHECKLIST_ITEM
  PLAN_SUPPLEMENT
  SUPPLEMENT
}

type IntakesChecklist {
  days: [IntakesChecklistDay!]!
  icon: String
  name: String!
}

type IntakesChecklistDay {
  date: Date!
  items: [AvailableChecklistItems!]!
}

type Interaction implements Node {
  createdAt: DateTime!
  description: String
  foods: String
  foodsSourceUrl: String
  id: ID!
  ingredient: DrugIngredient
  referenceUrl: String
  restrictions: [Restriction!]
  updatedAt: DateTime!
}

type InteractionConnection {
  edges: [InteractionEdge]!
  pageInfo: PageInfo!
}

type InteractionEdge {
  cursor: String!
  node: Interaction
}

input ItemDirectionsOfUseInput {
  friday: Boolean
  mealTime: TimeOfDay!
  monday: Boolean
  saturday: Boolean
  sunday: Boolean
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

scalar JSONString

type JourneyDialogType {
  dashboard: JourneyType!
  databaseId: String
  dialog: DialogType!
  id: ID!
  sortIndex: Int!
}

type JourneyProfileType implements Node {
  createdAt: DateTime
  dashboard: JourneyType!
  databaseId: String
  id: ID!
  profile: ProfileType!
  status: JourneyStatus
  subJourneys: [JourneyProfileType!]!
  updatedAt: DateTime
}

type JourneyProfileTypeConnection {
  edges: [JourneyProfileTypeEdge]!
  pageInfo: PageInfo!
}

type JourneyProfileTypeEdge {
  cursor: String!
  node: JourneyProfileType
}

enum JourneyStatus {
  CLOSE
  FINISH
  OPEN
}

type JourneyType {
  dashboardDialogs: [JourneyDialogType!]!
  databaseId: String
  daysIntoProgram: Int!
  externalUrl: String!
  header: String!
  id: ID!
  pdfs: [String!]!
  pdfsRel: [DashboardPDFType!]!
  program: Program
  subJourneys: [JourneyType!]!
  subTitle: String
  title: String
}

type LabTestReport {
  alert: Boolean
  alertAction: AlertAction
  alertStatus: AlertStatus
  alertText: String
  createdAt: DateTime!
  description: String
  externalId: String
  id: ID!
  image: String
  imageUrl: String
  isVisible: Boolean!
  labName: String!
  orderId: String
  orderingPhysician: String
  productId: String
  reportPdf: String
  requisitionId: String
  sampleCollectionDate: Date
  status: LabTestReportStatus
  testDate: DateTime
  testName: String!
  title: String!
  updatedAt: DateTime!
  videoUrl: String
}

type LabTestReportConnection {
  edges: [LabTestReportEdge]!
  pageInfo: PageInfo!
}

type LabTestReportEdge {
  cursor: String!
  node: LabTestReport
}

enum LabTestReportStatus {
  CREATED
  ERROR
  FULFILLED
  ORDERED
  PROCESS_COMPLETE
  RESULTS_DELIVERED
  RESULTS_READY
  RETURNED_TO_LAB
}

enum Language {
  EN
  ES
}

type Limitation {
  level: String!
  limit: Int!
  periodicity: String!
  subscriptionId: ID!
}

type LinkUserAssessment {
  message: String!
  success: Boolean!
}

input LinkUserAssessmentInput {
  assessmentId: ID!
}

type ListItem implements Node {
  aggregation(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): AggregateConnection!
  aisleName: String
  comment: String
  createdAt: DateTime!
  databaseId: String
  errors: [String]
  floatQuantity: Float
  grams: Float
  id: ID!
  ingredient: String!
  ingredientLine: String
  isCleared: Boolean!
  isDone: Boolean!
  numberOfServings: Int
  parse: JSONString!
  profile: ProfileType!
  quantity: String
  quantityMetric: String
  recipeId: String
  recipeName: String
  recipeServings: Int
  unit: String
  unitMetric: String
  updatedAt: DateTime!
}

type ListItemConnection {
  edges: [ListItemEdge]!
  pageInfo: PageInfo!
}

type ListItemEdge {
  cursor: String!
  node: ListItem
}

type LocationAutocomplete {
  city: String
  daylightSavingsTimeFlag: Boolean
  location: GeoPoint
  state: String
  suggest: String
  timezone: Int
  zipcode: String
}

type LogRecipeIngredient {
  id: String!
  mealType: MealType!
  name: String
  quantity: Float!
  serving: Int!
}

type Logger implements Node {
  adherenceScore: Float
  host: String
  id: ID!
  indexedAt: DateTime
  isPremium: Boolean
  location: [Float]
  method: String
  path: String
  profileId: String
  program: String
  requestBody: String
  requestGet: GenericScalar
  requestPost: GenericScalar
  response: GenericScalar
  restrictions: [String]
  statusCode: String
  uri: String
  user: String
  userId: String
}

type LoggerConnection {
  edges: [LoggerEdge]!
  pageInfo: PageInfo!
}

type LoggerEdge {
  cursor: String!
  node: Logger
}

type LoginUser {
  accessToken: String
  refreshToken: String
}

input MPTCustomOptionsInput {
  calories: Int
  carbsPerc: Int
  fatPerc: Int
  format: [MealTime!]
  program: ID
  proteinPerc: Int
}

input MPTFromDaysInput {
  fromDate: Date!
  profileId: ID!
  toDate: Date!
}

input MPTFromScratchDayInput {
  meals: [MPTFromScratchMealInput!]!
}

input MPTFromScratchInput {
  days: [MPTFromScratchDayInput!]!
}

input MPTFromScratchMealInput {
  mealType: MealTime!
  recipeId: ID!
  servings: Int
}

enum MPVariety {
  HIGH
  LOW
  MEDIUM
}

type MacroGoals {
  bmi: Int
  bmr: Int
  carbs: MacroNutrientGoal
  cd: Int
  dcig: Int
  fat: MacroNutrientGoal
  isUserGoal: Boolean
  name: String
  netcarbs: MacroNutrientGoal
  protein: MacroNutrientGoal
  tdee: Int
}

type MacroNutrientGoal {
  color: String
  goal: Float
  left: Float
  logged: Float
  lowerLimit: Float
  upperLimit: Float
}

type MacroNutrientLogged {
  goal: Int
  name: String!
  value: Int!
}

input MacroNutrientsRangeInput {
  ala: Range
  calcium: Range
  calories: Range
  carbs: Range
  carbsCalories: Range
  cholesterol: Range
  dha: Range
  dpa: Range
  epa: Range
  fat: Range
  fatCalories: Range
  fiber: Range
  iron: Range
  monounsaturatedFat: Range
  netcarbs: Range
  polyunsaturatedFat: Range
  potassium: Range
  protein: Range
  proteinCalories: Range
  saturatedFat: Range
  sodium: Range
  sugar: Range
  transFat: Range
  vitaminA: Range
  vitaminB6: Range
  vitaminB12: Range
  vitaminC: Range
  vitaminD: Range
  vitaminE: Range
}

type Meal {
  calories: Float
  id: String
  maxNumOfServings: Int
  meal: String
  numOfServings: Int
  recipe: Recipe
}

type MealBalanceIndexScore {
  errors: [String!]
  message: String
  score: Int
}

type MealCustomPlannerDays {
  day1: [MealPlanDayRecipe]
  day2: [MealPlanDayRecipe]
  day3: [MealPlanDayRecipe]
  day4: [MealPlanDayRecipe]
  day5: [MealPlanDayRecipe]
  day6: [MealPlanDayRecipe]
  day7: [MealPlanDayRecipe]
  day8: [MealPlanDayRecipe]
}

type MealLog implements Node {
  adherence: Float
  barcode: String
  brand: String
  createdAt: DateTime
  databaseId: String
  date: Date
  extraInfo: String
  id: ID!
  ingredients: [LogRecipeIngredient]
  isNew: Boolean
  isVerified: Boolean
  macrosLog: Nutrients
  mealDatabaseId: String
  mealTime: MealTime
  mealType: MealType
  mealTypeDisplayName: String
  name: String
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsFull: NutrientsFull @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutritionalInfo: NutritionalInfo
  quantity: Float
  recipe: Recipe
  secondaryInfoText: String
  serving: Int
  servingWeight: Float
  servings: [Servings]
  timestamp: DateTime
  updatedAt: DateTime
  userPid: String
}

type MealLogConnection {
  edges: [MealLogEdge]!
  pageInfo: PageInfo!
}

type MealLogEdge {
  cursor: String!
  node: MealLog
}

type MealLogMacroAggs {
  chocdf: Float
  fat: Float
  fibtg: Float
  netcarbs: Float
  procnt: Float
  sugar: Float
}

type MealPlanDay {
  calories: Float
  date(useDatetime: Boolean): String
  day: Int
  id: ID!
  meals: [Meal]
}

type MealPlanDayRecipe {
  mealTime: String
  programDate: Date
  recipe: Recipe
}

enum MealPlanDiversity {
  HIGH
  LOW
  MEDIUM
}

type MealPlanTemplate implements Node {
  coachId: ID
  coachTypes(after: String, before: String, first: Int, last: Int, offset: Int): CoachTypeConnection
  createdAt: DateTime!
  days: [MealPlanDay!]!
  description: String!
  id: ID!
  isPublic: Boolean!
  name: String!
}

type MealPlanTemplateConnection {
  edges: [MealPlanTemplateEdge]!
  pageInfo: PageInfo!
}

type MealPlanTemplateEdge {
  cursor: String!
  node: MealPlanTemplate
}

type MealPlannerDayTime {
  breakfast: [Recipe]
  dinner: [Recipe]
  lunch: [Recipe]
  programDate: Date
  snack: [Recipe]
}

type MealPlannerDays {
  day1: MealPlannerDayTime
  day2: MealPlannerDayTime
  day3: MealPlannerDayTime
  day4: MealPlannerDayTime
  day5: MealPlannerDayTime
  day6: MealPlannerDayTime
  day7: MealPlannerDayTime
  day8: MealPlannerDayTime
}

enum MealPlannerQueryType {
  DAY_AGGREGATE
  RAW
  SUGGESTIONS
}

type MealProxy {
  meal: Meal!
}

enum MealTime {
  BREAKFAST
  DINNER
  LUNCH
  SNACK
}

type MealTrack {
  date: Date!
  meal: Meal!
  mealId: ID!
  value: MealTrackStatus!
}

enum MealTrackStatus {
  ATE
  DELETE
  OTHER_FOLLOWING
  OTHER_NOT_FOLLOWING
  SKIPPED
}

enum MealType {
  BRANDED_FOOD
  COMMON_FOOD
  MEAL_PLAN_MEAL
  MENU_ITEM
  MY_BRANDED_FOOD
  MY_COMMON_FOOD
  OWN_ITEM
  OWN_RECIPE
  RECIPE
  USDA_MEAL
  USER_RECIPE
}

type MenuItem implements Node {
  adherence: Adherence
  annotation: GenericScalar
  confirmedIngredients: [String]
  course: String @deprecated(reason: "use `courses` a menu item can have more than one course")
  courses: [String]
  createdAt: DateTime
  databaseId: String
  deciderSource: String
  deciderVersion: Int
  description: String
  favoritesCount: Int
  hasNutrients: Boolean
  id: ID!
  indexedAt: DateTime
  ingredients: [Ingredient]
  isActive: Boolean
  isAnnotated: Boolean
  isIndexed: Boolean
  isRecommended: Boolean
  isSourceActive: Boolean
  isUserFavorite: Boolean
  isValidated: Boolean
  language: String
  maxPrice: Float
  mayHave: [Ingredient]
  mealTags: [String]
  menu: String
  minPrice: Float
  name: String
  nutrients: Nutrients @deprecated(reason: "use `nutritional_info`")
  nutritionalInfo: NutritionalInfo
  parent: String
  portionSize: String
  programScore: Float
  programs: [String]
  programsIds: [String]
  restaurant: Restaurant
  restaurantId: String
  restaurantName: String
  sectionName: String
  tags: [String]
  trustMe: Boolean
  type: String
  updatedAt: DateTime
  usersFavorite: [String]
}

type MenuItemConnection {
  edges: [MenuItemEdge]!
  pageInfo: PageInfo!
}

type MenuItemEdge {
  cursor: String!
  node: MenuItem
}

type MergeUser {
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input MergeUserInput {
  userOrigin: ID!
  userTarget: ID!
}

type Money {
  amount: Float!
  currencyCode: String!
}

type Mutation {
  addBiomarker(input: AddBiomarkerInput!): AddBiomarker
  addBiomarkerResults(input: AddBiomarkerResultsInput!): AddBiomarkerResults
  addExerciseEntry(calories: Int, datetime: DateTime!, durationMinutes: Int!, intensity: ExerciseIntensity!, source: SourceType, type: ExerciseType!): AddExerciseEntry!
  addFavoriteArticle(articleId: ID!): AddFavoriteArticle

  """
  addFoodLog logs that the user ate specific food, like a recipe, a personal recipe, a meal plan's meal, etc
  """
  addFoodLog(date: Date!, foodId: ID!, grams: Int, mealTime: MealTime!, milligrams: Int, portionModifier: String, servings: Float, time: Time): AddFoodLog!
  addGPTFoodLog(input: AddGPTFoodLogInput!): AddGPTFoodLog

  """addHRVLog add HRV log"""
  addHRVLog(source: SourceType, timestamp: DateTime, value: PositiveFloat!): AddHRVLog!

  """addHeartRateLog add Heart Rate Log log"""
  addHeartRateLog(source: SourceType, timestamp: DateTime, value: PositiveInt!): AddHeartRateLog!
  addRecipesToShoppingList(recipeIds: [String]!): AddRecipesToShoppingList

  """addSleepQualityScore add sleep quality score log"""
  addSleepQualityScore(date: Date, source: SourceType, value: Int!): AddSleepQualityScore!

  """addSleepTime add sleep time log"""
  addSleepTime(date: Date, source: SourceType, value: Int!): AddSleepTime!
  addStepsCount(datetime: DateTime!, source: SourceType, steps: Int!): AddStepsCount!
  addToShoppingList(recipeId: String!): AddToShoppingList
  bulkCreateEntries(exerciseEntries: [ExerciseEntryInput!], heartRateEntries: [HeartRateEntryInput!], hrvEntries: [HRVEntryInput!], hydrationEntries: [HydrationEntryInput!], sleepQualityScoreEntries: [SleepQualityEntryInput!], sleepTimeEntries: [SleepTimeEntryInput!], stepsCountEntries: [StepCountEntryInput!], weightEntries: [WeightEntryInput!]): BulkCreateEntries!
  cancelAppointment(appointment: ID!): CancelAppointment
  changeMealPlannerDayMeal(day: Int!, mealTime: MealTime!, recipeId: String!): ChangeMealPlannerDayMeal

  """
  checkIntake creates a log checking that the user ate food that they was supposed to eat as part of a plan
  """
  checkIntake(category: IntakeCategory!, date: Date!, itemId: ID!, timeOfDay: TimeOfDay): CheckIntake!
  checkTodayFood(date: Date!, itemId: ID!): CheckTodayFoodEntry @deprecated(reason: "No longer supported. Use checkIntake instead")
  checkTodaySupplement(date: Date!, itemId: ID!): CheckTodaySupplementEntry @deprecated(reason: "No longer supported. Use checkIntake instead")
  checkoutCreate(input: CheckoutCreateInput!): CheckoutCreate
  clearShoppingList: ClearShoppingList
  clearShoppingListCheckedItems: ClearShoppingListCheckedItems
  confirmFoodLogAssistant(input: ConfirmFoodLogAssistantInput!): ConfirmFoodLogAssistant
  createAppointment(input: CreateAppointmentInput!): CreateAppointment
  createArticleRecommended(input: CreateArticleRecommendedInput!): CreateArticleRecommended
  createAssessment(input: CreateAssessmentInput!): CreateAssessment
  createBiomarkerCategory(input: CreateBiomarkerCategoryInput!): CreateBiomarkerCategory
  createCoachTeam(input: CreateCoachTeamInput!): CreateCoachTeam
  createCoachType(input: CreateCoachTypeInput!): CreateCoachType
  createContentCategory(input: CreateContentCategoryInput!): CreateContentCategory
  createContentLibrary(input: CreateContentLibraryInput!): CreateContentLibrary
  createContentTag(name: String!): CreateContentTag
  createDailyRecapAnswer(input: CreateDailyRecapAnswerInput!): CreateDailyRecapAnswer
  createDailyRecapEntry(answerId: String!, date: Date!, questionId: String!): CreateDailyRecapEntry
  createDailyRecapQuestion(input: CreateDailyRecapQuestionInput!): CreateDailyRecapQuestion
  createGooglePlayTransaction(acknowledged: Boolean!, autoRenewing: Boolean!, orderId: String!, packageName: String!, productId: String!, purchaseState: Int!, purchaseTime: Float!, purchaseToken: String!, subscriptionSku: String!): CreateGooglePlayTransaction
  createLabTestReport(alert: Boolean, alertAction: AlertAction, alertStatus: AlertStatus, alertText: String, description: String, externalId: String, image: Upload, imageUrl: String, isVisible: Boolean, labName: String!, orderId: String, orderingPhysician: String, productId: String, reportPdf: Upload, requisitionId: String, sampleCollectionDate: Date, status: LabTestReportStatus, testDate: DateTime, testName: String!, title: String!, videoUrl: String): CreateLabTestReport
  createMealEntry(date: Date, mealId: ID!, timezone: String, value: MealTrackStatus): CreateMealEntry
  createMealLog(customServingEquivalent: Float, date: Date, mealDatabaseId: String!, mealTime: MealTime!, mealType: MealType!, quantity: Float!, serving: Float, time: Time): CreateMealLogMutation
  createMealPlanTemplate(coach: ID, customOptions: MPTCustomOptionsInput, description: String!, fromDays: MPTFromDaysInput, fromScratch: MPTFromScratchInput, isPublic: Boolean, name: String!): CreateMealPlanTemplate
  createMyBrandedFoods(input: CreateMyBrandedFoodInput!): CreateMyBrandedFood
  createMyChecklistItem(directionsOfUse: [ItemDirectionsOfUseInput!], header: String!, tags: [String!], text: String): CreateMyChecklistItem

  """
  checkIntake creates a log checking that the user fulfilled the action in one of their personal MyChecklistItem
  """
  createMyChecklistItemLog(date: Date!, itemId: ID!, timeOfDay: TimeOfDay!): CreateMyChecklistItemLog!
  createMyCommonFoods(input: CreateMyCommonFoodInput!): CreateMyCommonFood
  createMyRecipe(input: CreateMyRecipeInput!): CreateMyRecipe
  createNote(coach: ID, eventId: ID, text: String!, title: String!): CreateNote
  createOwnMealLog(barcode: String, brand: String, date: Date, logAfterCreation: Boolean, mealTime: MealTime, mealTimes: [MealTime], mealType: MealType!, name: String!, ownNutrients: OwnNutrients!, ownServing: OwnServing!): CreateOwnMealLogMutation
  createOwnRecipe(ingredients: [OwnRecipeIngredient], logAfterCreation: Boolean, quantity: Float!, recipeName: String!): CreateOwnRecipe
  createProfileBiomarkers(cholesterolLdl: Float, cortisol: Float, ferritin: Float, hba1c: Float, totalCholesterol: Float, vitaminB12: Float, vitaminD: Float): CreateProfileBiomarkers
  createProfileCustomAttributes(append: Boolean, attributes: [ProfileCustomAttribute!]!): CreateProfileCustomAttributes
  createQuestion(input: CreateQuestionInput!): CreateQuestion
  createQuizResult(answers: [String]!, result: String!): CreateQuizResult
  createSupplement(input: CreateSupplementInput!): CreateSupplement
  createSupplementPlan(fromTemplate: ID, input: CreateSPInput): CreateSupplementPlan
  createSupplementRecommended(input: CreateSupplementRecommendedInput!): CreateSupplementRecommended
  createUser(birthdate: Date, email: String!, emailPasswordNotification: Boolean, extraData: JSONString, name: String!, password: String, phone: String, program: String, restrictions: [ID!], subscription: ID): CreateUser
  createWeightEntry(date: Date!, source: SourceType, value: Float!): CreateWeightEntry
  deleteArticleRecommended(id: ID!): DeleteArticleRecommended
  deleteAssessment(id: ID!): DeleteAssessment
  deleteBiomarkerCategory(id: ID!): DeleteBiomarkerCategory
  deleteCoachTeam(id: ID!): DeleteCoachTeam
  deleteCoachType(id: ID!): DeleteCoachType
  deleteContentCategory(id: ID!): DeleteContentCategory
  deleteContentLibrary(id: ID!): DeleteContentLibrary
  deleteContentTag(id: ID!): DeleteContentTag
  deleteDailyRecapAnswer(id: ID!): DeleteDailyRecapAnswer
  deleteDailyRecapEntry(date: Date!, questionId: String!): DeleteDailyRecapEntry
  deleteDailyRecapQuestion(id: ID!): DeleteDailyRecapQuestion
  deleteExerciseEntry(id: ID!): DeleteExerciseEntry!

  """deleteFoodLog deletes a food log by ID"""
  deleteFoodLog(id: ID!): DeleteFoodLog!

  """deleteHRVLog delete hrv log entry"""
  deleteHRVLog(id: ID!): DeleteHRVLog!

  """deleteHeartRateLog delete Heart Rate Log"""
  deleteHeartRateLog(id: ID!): DeleteHeartRateLog!
  deleteLabTestReport(id: ID!): DeleteLabTestReport
  deleteMealPlanTemplate(coach: ID, id: ID!): DeleteMealPlanTemplate
  deleteMyBrandedFood(id: String!): DeleteMyBrandedFood
  deleteMyChecklistItem(id: ID!): DeleteMyChecklistItem

  """deleteMyChecklistItemLog deletes a MyChecklistItem log by ID"""
  deleteMyChecklistItemLog(date: Date!, itemId: ID!, timeOfDay: TimeOfDay!): DeleteMyChecklistItemLog!
  deleteMyCommonFood(id: String!): DeleteMyCommonFood
  deleteMyProfile: HardDeleteMyProfileMutation
  deleteMyRecipe(id: ID!): DeleteMyRecipe
  deleteNote(noteId: ID!): DeleteNote
  deleteQuestion(id: ID!): DeleteQuestion

  """deleteSleepQualityScore delete sleep quality score entry"""
  deleteSleepQualityScore(id: ID!): DeleteSleepQualityScore!

  """deleteSleepTime delete sleep time entry"""
  deleteSleepTime(id: ID!): DeleteSleepTime!
  deleteStepsCount(id: ID!): DeleteStepsCount!
  deleteSupplementRecommended(id: ID!): DeleteSupplementRecommended
  deleteWeightEntry(date: Date!): DeleteWeightEntry
  duplicateMealPlanTemplate(id: ID!): DuplicateMealPlanTemplate
  generateMagicLink(email: String!): GenerateMagicLink
  generateMealPlan(addDays: Boolean, breakfastDistribution: Float, dinnerDistribution: Float, fromTemplate: ID, ignoreLock: Boolean, includeFavorites: Boolean, isCache: Boolean, kcalLimit: Float, lunchDistribution: Float, maxIngredientsCount: IntValueByMealTime, maxNumOfServings: Int, maxServingWeight: Int, maxTimeMinutes: IntValueByMealTime, minServingWeight: Int, repeat: DateTime, snackDistribution: Float, startDate: Date, variety: MPVariety): GenerateMealPlan
  generateSimpleMealPlan(addDays: Boolean, boostAdherence: Boolean, filters: SimpleMPFiltersInput, format: [MealTime!], ignoreLock: Boolean, repeat: DateTime, variety: MPVariety): GenerateSimpleMealPlan
  generateVideoZoomToken(input: GenerateVideoZoomTokenInput!): GenerateVideoZoomTokenPayload
  linkUserAssessment(input: LinkUserAssessmentInput!): LinkUserAssessment
  login(userId: String!): LoginUser
  mergeUser(input: MergeUserInput!): MergeUser
  processAppleReceipt(input: ProcessAppleReceiptInput!): ProcessAppleReceipt
  profileMacroGoalsSettings(activityLevel: ActivityLevel!, biologicalSex: BiologicalSex!, birthdate: Date!, goalsOn: Boolean!, height: Float!, isImperial: Boolean, startingWeight: Float!, targetWeight: Float!, weeklyWeightGoal: WeeklyWeightGoal!): ProfileMacroGoalsSettings
  profileMealPlanSettings(calories: Int!, carbsPerc: Float!, error: Float!, fatPerc: Float!, format: [MealTime], omega3Perc: Float, proteinPerc: Float!): ProfileMealPlanSettings @deprecated(reason: "This doesn't allow doing settings reset. Use updateMealPlanSettings instead.")
  profileRestrictionsUpdate(replace: Boolean, restrictions: [ID]): ProfileRestrictionsUpdate
  publishEvent(appVersion: String!, client: String!, eventType: EventType!, location: GenericScalar, timezone: String!): PublishEvent
  purchaseMealRecipe(externalId: String, profileId: String!, recipeId: ID!): PurchaseMealRecipe
  removeFavoriteArticle(articleId: ID!): RemoveFavoriteArticle
  removeFromShoppingList(recipeId: String!): RemoveFromShoppingList
  removeMealLog(databaseId: String!): RemoveMealLogMutation
  removeMealPlan: RemoveMealPlan
  removeMealPlanRecipe(mealId: ID!): RemoveMealPlanRecipe
  removeOwnMeal(databaseId: String!): RemoveOwnMeal
  requestAccountDeletion: RequestAccountDeletion
  requestResetPassword(email: String!): RequestResetPassword
  resendAppointmentConfirmationEmail(appointment: ID!, profile: ID): ResendAppointmentConfirmationEmail
  resetPassword(code: String!, newPassword: String!): ResetPassword
  selectDailyRecapQuestions(questions: [ID!]!): SelectDailyRecapQuestions!
  sendFeedback(message: String!, subject: String!): SendFeedback
  sensitiveProfileAttributes(attributes: String, signingPublicKey: String): SensitiveProfileAttributes
  setActiveSource(source: SourceType!): SetActiveSource
  setMealPlanToTemplate(profileId: ID!, templateId: ID!): SetMealPlanToTemplate
  setUserAnswers(input: SetUserAnswersInput!): SetUserAnswers
  startJourneys(daysUnlocked: Int, override: Boolean): StartJourneys
  startOverMealPlan: StartOverMealPlan
  swapMealPlanRecipe(mealId: String, mealTag: MealTime, recipeId: String!, serving: Int): SwapMealPlanRecipe
  toggleShoppingListItem(isAggregate: Boolean!, itemId: String!): ToggleShoppingListItem
  toggleTaskCompleted(keysHash: String!): ToggleTaskCompleted

  """uncheckIntake is the opposite of checkIntake. It undoes the check"""
  uncheckIntake(category: IntakeCategory!, date: Date!, itemId: ID!, timeOfDay: TimeOfDay): UncheckIntake!
  uncheckTodayFood(date: Date!, itemId: ID!): UncheckTodayFood @deprecated(reason: "No longer supported. Use uncheckIntake instead")
  uncheckTodaySupplement(date: Date!, itemId: ID!): UncheckTodaySupplement @deprecated(reason: "No longer supported. Use uncheckIntake instead")
  unlinkUserAssessment(input: LinkUserAssessmentInput!): UnlinkUserAssessment
  updateAnswer(input: UpdateAnswerInput!): UpdateAnswer
  updateAppointment(input: UpdateAppointmentInput!): UpdateAppointment
  updateAppointmentCredits(appointmentType: ID!, decrease: Int, increase: Int, labTestReports: [ID], profile: ID!, value: Int): UpdateAppointmentCredits
  updateArticleRecommended(input: UpdateArticleRecommendedInput!): UpdateArticleRecommended
  updateAssessment(input: UpdateAssessmentInput!): UpdateAssessment
  updateBiomarker(input: UpdateBiomarkerInput!): UpdateBiomarker
  updateBiomarkerCategory(input: UpdateBiomarkerCategoryInput!): UpdateBiomarkerCategory
  updateCoachTeam(input: UpdateCoachTeamInput!): UpdateCoachTeam
  updateCoachType(input: UpdateCoachTypeInput!): UpdateCoachType
  updateContentCategory(input: UpdateContentCategoryInput!): UpdateContentCategory
  updateContentLibrary(input: UpdateContentLibraryInput!): UpdateContentLibrary
  updateContentTag(id: ID!, name: String!): UpdateContentTag
  updateDailyRecapAnswer(input: UpdateDailyRecapAnswerInput!): UpdateDailyRecapAnswer
  updateDailyRecapQuestion(input: UpdateDailyRecapQuestionInput!): UpdateDailyRecapQuestion
  updateHydration(action: ActionType!, date: Date!, source: SourceType): UpdateHydration
  updateJourneyStatus(journeyId: String!, status: JourneyStatus!): UpdateJourneyStatus
  updateLabTestReport(alert: Boolean, alertAction: AlertAction, alertStatus: AlertStatus, alertText: String, description: String, externalId: String, id: ID!, image: Upload, imageUrl: String, isVisible: Boolean, labName: String, orderId: String, orderingPhysician: String, productId: String, reportPdf: Upload, requisitionId: String, sampleCollectionDate: Date, status: LabTestReportStatus, testDate: DateTime, testName: String, title: String, videoUrl: String): UpdateLabTestReport
  updateMealLog(customServingEquivalent: Float, databaseId: String!, date: Date, mealTime: MealTime, quantity: Float, serving: Float, time: Time): UpdateMealLogMutation
  updateMealPlanSettings(overwrite: UpdateMPSettingsInput, update: UpdateMPSettingsInput): UpdateMealPlanSettings
  updateMealPlanTemplate(coach: ID, coachTypes: [ID!], description: String, id: ID!, isPublic: Boolean, mealPlanDays: MPTFromScratchInput, name: String): UpdateMealPlanTemplate
  updateMyBrandedFood(id: String!, input: UpdateMyBrandedFoodInput!): UpdateMyBrandedFood
  updateMyChecklistItem(directionsOfUse: [ItemDirectionsOfUseInput!], header: String, id: ID!, tags: [String!], text: String): UpdateMyChecklistItem
  updateMyCommonFood(id: String!, input: UpdateMyCommonFoodInput!): UpdateMyCommonFood
  updateMyRecipe(id: ID!, input: UpdateMyRecipeInput!): UpdateMyRecipe
  updateNote(coach: ID, noteId: ID!, text: String, title: String): UpdateNote
  updateOwnMeal(barcode: String, brand: String, databaseId: String!, date: Date, mealTime: MealTime, mealType: MealType, name: String, ownNutrients: OwnNutrients!, ownServing: OwnServing!): UpdateOwnMealMutation
  updateOwnRecipe(databaseId: String!, ingredients: [OwnRecipeIngredient], quantity: Float, recipeName: String): UpdateOwnRecipe
  updateProfile(birthdate: Date, country: String, email: String, favoriteCuisines: [String!], isImperial: Boolean, language: Language, mpDiversity: MealPlanDiversity, name: String, timezone: String): UpdateProfile
  updateProfileBiomarkers(cholesterolLdl: Float, cortisol: Float, ferritin: Float, hba1c: Float, totalCholesterol: Float, vitaminB12: Float, vitaminD: Float): UpdateProfileBiomarkers
  updateProtocol(input: UpdateProtocolInput!): UpdateProtocol
  updateQuestion(input: UpdateQuestionInput!): UpdateQuestion
  updateShoppingListRecipeServings(numberOfServings: Int!, recipeId: String!): UpdateShoppingListRecipeServings
  updateSubscription(profileId: String, subscriptionId: String!, userId: String): UpdateSubscription
  updateSupplement(input: UpdateSupplementInput!): UpdateSupplement
  updateSupplementPlan(input: UpdateSPInput!): UpdateSupplementPlan
  updateSupplementRecommended(input: UpdateSupplementRecommendedInput!): UpdateSupplementRecommended
  updateThirdPartyTrackerComponent(input: UpdateThirdPartyTrackerComponentInput!): UpdateThirdPartyTrackerComponent
  updateUserAssessmentScore(input: UpdateUserAssessmentScoreInput!): UpdateUserAssessmentScore
  updateUserProgram(programId: String!): UpdateUserProgram
  updateUserProgress(input: UpdateUserProgressInput!): UpdateUserProgress
  userFavoriteMenuitem(menuitemId: String!): UserFavoriteMenuItem
  userFavoriteRecipe(recipeId: String!): UserFavoriteRecipe
  userFavoriteRestaurant(restaurantId: String!): UserFavoriteRestaurant
}

type MyBrandedFood implements Node {
  brandName: String
  brandOwner: String!
  brandedFoodCategory: String
  calories: Float
  dataType: String
  description: String
  foodDataId: String
  gtinUpc: String!
  householdServingFulltext: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  profileId: String!
  servingSize: Float!
  servingSizeUnit: String!
  tags: [String!]!
}

type MyBrandedFoodConnection {
  count: Int!
  edges: [MyBrandedFoodEdge]!
  pageInfo: PageInfo!
}

type MyBrandedFoodEdge {
  cursor: String!
  node: MyBrandedFood
}

type MyBrandedFoodProxy {
  myBrandedFood: MyBrandedFood!
}

type MyChecklistItem implements Node {
  createdAt: DateTime!
  directionsOfUse: [CheckItemDirections!]
  header: String!
  id: ID!
  tags: [String!]!
  text: String
  updatedAt: DateTime!
}

type MyChecklistItemConnection {
  edges: [MyChecklistItemEdge]!
  pageInfo: PageInfo!
}

type MyChecklistItemEdge {
  cursor: String!
  node: MyChecklistItem
}

type MyChecklistItemOnPlan {
  checked: Boolean!
  myChecklistItem: MyChecklistItem!
  timeOfDay: TimeOfDay
}

type MyChecklistLog {
  id: ID!
  myChecklistItem: MyChecklistItem!
  myChecklistItemId: ID!
  timeOfDay: TimeOfDay!
}

type MyChecklistLogs {
  dates: [MyChecklistLogsDay!]!
}

type MyChecklistLogsDay {
  date: Date!
  logs: [MyChecklistLog!]!
}

type MyCommonFood implements Node {
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  isActive: Boolean!
  isCore: Boolean!
  isGeneric: Boolean!
  name: String!
  nutrients: [Nutrient!]!
  portions: [Portion]
  profileId: String!
  tags: [String!]!
}

type MyCommonFoodConnection {
  count: Int!
  edges: [MyCommonFoodEdge]!
  pageInfo: PageInfo!
}

type MyCommonFoodEdge {
  cursor: String!
  node: MyCommonFood
}

type MyCommonFoodProxy {
  myCommonFoodProxy: MyCommonFood!
}

interface Node {
  id: ID!
}

type Note implements Node {
  createdAt: DateTime!
  createdBy: Coach
  id: ID!
  text: String
  title: String!
  updatedAt: DateTime!
  updatedBy: Coach
}

type NoteConnection {
  edges: [NoteEdge]!
  pageInfo: PageInfo!
}

type NoteEdge {
  cursor: String!
  node: Note
}

type Nutrient {
  amount: Float
  name: String
  type: NutrientEnum!
  unit: String
}

type NutrientAggregationsByFoodLog {
  alphaLinolenicacid: NutrientGoalComparison
  biotin: NutrientGoalComparison
  calcium: NutrientGoalComparison
  chloride: NutrientGoalComparison
  chocdf: NutrientGoalComparison
  choline: NutrientGoalComparison
  chromium: NutrientGoalComparison
  copper: NutrientGoalComparison
  fat: NutrientGoalComparison
  fluoride: NutrientGoalComparison
  folate: NutrientGoalComparison
  iodine: NutrientGoalComparison
  iron: NutrientGoalComparison
  linoleicacid: NutrientGoalComparison
  magnesium: NutrientGoalComparison
  manganese: NutrientGoalComparison
  molybdenum: NutrientGoalComparison
  netcarbs: NutrientGoalComparison
  niacin: NutrientGoalComparison
  pantothenicacid: NutrientGoalComparison
  phosphorus: NutrientGoalComparison
  potassium: NutrientGoalComparison
  procnt: NutrientGoalComparison
  riboflavin: NutrientGoalComparison
  selenium: NutrientGoalComparison
  sodium: NutrientGoalComparison
  thiamin: NutrientGoalComparison
  totalfiber: NutrientGoalComparison
  vitamina: NutrientGoalComparison
  vitaminb6: NutrientGoalComparison
  vitaminb12: NutrientGoalComparison
  vitaminc: NutrientGoalComparison
  vitamind: NutrientGoalComparison
  vitamine: NutrientGoalComparison
  vitamink: NutrientGoalComparison
  zinc: NutrientGoalComparison
}

enum NutrientEnum {
  ACETIC_ACID
  ALANINE
  ALCOHOL_ETHYL
  ARGININE
  ASH
  ASPARTIC_ACID
  BETAINE
  BETA_SITOSTANOL
  BETA_SITOSTEROL
  BIOTIN
  BORON_B
  BRASSICASTEROL
  CAFFEINE
  CALCIUM_CA
  CAMPESTANOL
  CAMPESTEROL
  CARBOHYDRATE_BY_SUMMATION
  CARBOHYDRATE_OTHER
  CARBS
  CAROTENE_ALPHA
  CAROTENE_BETA
  CHLORINE_CL
  CHOLESTEROL
  CHOLINE_FREE
  CHOLINE_FROM_GLYCEROPHOSPHOCHOLINE
  CHOLINE_FROM_PHOSPHOCHOLINE
  CHOLINE_FROM_PHOSPHOTIDYL_CHOLINE
  CHOLINE_FROM_SPHINGOMYELIN
  CHOLINE_TOTAL
  CHROMIUM_CR
  CIS_BETA_CAROTENE
  CIS_LUTEIN_ZEAXANTHIN
  CIS_LYCOPENE
  COBALT_CO
  COPPER_CU
  CRYPTOXANTHIN_ALPHA
  CRYPTOXANTHIN_BETA
  CYSTEINE
  CYSTINE
  DELTA_5_AVENASTEROL
  DHA
  DPA
  ENERGY
  EPA
  EPIGALLOCATECHIN_3_GALLATE
  FAT
  FATTY_ACIDS_TOTAL_MONOUNSATURATED
  FATTY_ACIDS_TOTAL_POLYUNSATURATED
  FATTY_ACIDS_TOTAL_SATURATED
  FATTY_ACIDS_TOTAL_TRANS
  FATTY_ACIDS_TOTAL_TRANS_DIENOIC
  FATTY_ACIDS_TOTAL_TRANS_MONOENOIC
  FATTY_ACIDS_TOTAL_TRANS_POLYENOIC
  FIBER_INSOLUBLE
  FIBER_SOLUBLE
  FIBER_TOTAL_DIETARY
  FLUORIDE_F
  FOLATE_DFE
  FOLATE_FOOD
  FOLATE_TOTAL
  FOLIC_ACID
  FRUCTOSE
  GALACTOSE
  GLUCOSE_DEXTROSE
  GLUTAMIC_ACID
  GLUTAMINE
  GLYCINE
  HISTIDINE
  HYDROXYPROLINE
  INOSITOL
  INULIN
  IODINE_I
  IRON_FE
  ISOLEUCINE
  LACTIC_ACID
  LACTOSE
  LEUCINE
  LUTEIN
  LUTEIN_ZEAXANTHIN
  LYCOPENE
  LYSINE
  MAGNESIUM
  MALTOSE
  MANGANESE_MN
  METHIONINE
  MOLYBDENUM_MO
  NIACIN
  NICKEL_NI
  O5_FORMYLTETRAHYDROFOLIC_ACID_5_HCOH4
  O5_METHYL_TETRAHYDROFOLATE_5_MTHF
  O10_FORMYL_FOLIC_ACID_10HCOFA
  O25_HYDROXYCHOLECALCIFEROL
  PANTOTHENIC_ACID
  PHENYLALANINE
  PHOSPHORUS_P
  PHYTOENE
  PHYTOFLUENE
  PHYTOSTEROLS
  PHYTOSTEROLS_OTHER
  POTASSIUM_K
  PROLINE
  PROTEIN
  RETINOL
  RIBOFLAVIN
  RIBOSE
  SELENIUM_SE
  SERINE
  SODIUM_NA
  SORBITOL
  SPECIFIC_GRAVITY_SP
  STARCH
  STIGMASTEROL
  SUCROSE
  SUGARS_ADDED
  SUGARS_TOTAL_INCLUDING_NLEA
  SUGARS_TOTAL_NLEA
  SULFUR_S
  TAURINE
  THEOBROMINE
  THIAMIN
  THREONINE
  TOCOPHEROL_BETA
  TOCOPHEROL_DELTA
  TOCOPHEROL_GAMMA
  TOCOTRIENOL_ALPHA
  TOCOTRIENOL_BETA
  TOCOTRIENOL_DELTA
  TOCOTRIENOL_GAMMA
  TOTAL_FAT_NLEA
  TOTAL_SUGAR_ALCOHOLS
  TRANS_BETA_CAROTENE
  TRANS_LYCOPENE
  TRYPTOPHAN
  TYROSINE
  VALINE
  VITAMIN_A_IU
  VITAMIN_A_RAE
  VITAMIN_B_6
  VITAMIN_B_12
  VITAMIN_B_12_ADDED
  VITAMIN_C_TOTAL_ASCORBIC_ACID
  VITAMIN_D2_ERGOCALCIFEROL
  VITAMIN_D3_CHOLECALCIFEROL
  VITAMIN_D_D2_D3
  VITAMIN_D_D2_D3_INTERNATIONAL_UNITS
  VITAMIN_E
  VITAMIN_E_ADDED
  VITAMIN_E_ALPHA_TOCOPHEROL
  VITAMIN_E_LABEL_ENTRY_PRIMARILY
  VITAMIN_K_DIHYDROPHYLLOQUINONE
  VITAMIN_K_MENAQUINONE_4
  VITAMIN_K_PHYLLOQUINONE
  WATER
  XYLITOL
  ZEAXANTHIN
  ZINC_ZN
}

input NutrientFilterInput {
  nutrient: NutrientEnum!
  range: RangeFilter
}

type NutrientGoalComparison {
  goal: Float
  value: Float
}

input NutrientInput {
  amount: Float!
  nutrient: NutrientEnum!
  unit: String!
}

type Nutrients {
  chocdf: Float
  fat: Float
  fibtg: Float
  netcarbs: Float
  procnt: Float
  sugar: Float
}

type NutrientsFull {
  ca: Float
  chole: Float
  cholesterol: Float
  enercKcal: Float
  energy: Float
  fams: Float
  fapu: Float
  fasat: Float
  fatrn: Float
  fe: Float
  fiber: Float
  k: Float
  na: Float
  potassiumK: Float
  saturatedFat: Float
  sodiumNa: Float
  transFats: Float
  vitaIu: Float
  vitc: Float
}

type NutrientsPerServing {
  ala: Float
  calcium: Float
  calories: Float
  carbs: Float
  cholesterol: Float
  choline: Float
  copper: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  fiber: Float
  iodine: Float
  iron: Float
  magnesium: Float
  manganese: Float
  molybdenum: Float
  monounsaturatedFat: Float
  netcarbs: Float
  omega3: Float
  phosphorus: Float
  polyunsaturatedFat: Float
  potassium: Float
  protein: Float
  saturatedFat: Float
  selenium: Float
  sodium: Float
  sugar: Float
  transFat: Float
  vitaminA: Float
  vitaminB1: Float
  vitaminB2: Float
  vitaminB3: Float
  vitaminB5: Float
  vitaminB6: Float
  vitaminB7: Float
  vitaminB9: Float
  vitaminB12: Float
  vitaminC: Float
  vitaminD: Float
  vitaminE: Float
  vitaminK: Float
  zinc: Float
}

type NutritionEstimates {
  calories: Float
  carbs: Float
  fat: Float
  protein: Float
}

type NutritionalInfo {
  ala: Float
  calcium: Float
  calories: Float
  carbs: Float
  cholesterol: Float
  choline: Float
  copper: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  fiber: Float
  iodine: Float
  iron: Float
  magnesium: Float
  manganese: Float
  molybdenum: Float
  monounsaturatedFat: Float
  netcarbs: Float
  omega3: Float
  phosphorus: Float
  polyunsaturatedFat: Float
  potassium: Float
  protein: Float
  saturatedFat: Float
  selenium: Float
  sodium: Float
  sugar: Float
  transFat: Float
  vitaminA: Float
  vitaminB1: Float
  vitaminB2: Float
  vitaminB3: Float
  vitaminB5: Float
  vitaminB6: Float
  vitaminB7: Float
  vitaminB9: Float
  vitaminB12: Float
  vitaminC: Float
  vitaminD: Float
  vitaminE: Float
  vitaminK: Float
  zinc: Float
}

enum Operation {
  ADD
  REMOVE
  REPLACE
}

type OutoCompleteConnection {
  edges: [OutoCompleteEdge]!
  pageInfo: PageInfo!
}

type OutoCompleteEdge {
  cursor: String!
  node: Suggestion
}

input OwnNutrients {
  ca: Float
  chocdf: Float!
  chole: Float
  enercKcal: Float
  fams: Float
  fapu: Float
  fasat: Float
  fat: Float!
  fatrn: Float
  fe: Float
  fibtg: Float
  k: Float
  na: Float
  procnt: Float!
  sugar: Float
  vitaIu: Float
  vitc: Float
}

input OwnRecipeIngredient {
  id: String!
  mealType: MealType!
  quantity: Float!
  serving: Int!
}

input OwnServing {
  equivalent: Float!
  name: String!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Portion {
  amount: Float
  gramWeight: Float
  modifier: String
  seqNum: Int
  unit: String
}

input PortionInput {
  amount: Float!
  gramWeight: Float!
  modifier: String
  unit: String!
}

scalar PositiveFloat

scalar PositiveInt

enum PriceRate {
  RATE_0
  RATE_1
  RATE_2
  RATE_3
  RATE_4
}

type ProcessAppleReceipt {
  message: String!
  success: Boolean!
}

input ProcessAppleReceiptInput {
  isInitial: Boolean
  receiptData: String!
}

type ProductOption {
  name: String!
  values: [String!]
}

type ProductType implements Node {
  createdAt: DateTime
  id: ID!
  isActive: Boolean!
  name: String!
  programs(after: String, before: String, first: Int, isActive: Boolean, isPremium: Boolean, last: Int, offset: Int): ProgramConnection!
  updatedAt: DateTime
}

type ProductTypeConnection {
  edges: [ProductTypeEdge]!
  pageInfo: PageInfo!
}

type ProductTypeEdge {
  cursor: String!
  node: ProductType
}

type ProductVariant {
  availableForSale: Boolean!
  id: ID!
  price: Money!
  title: String!
}

type ProfileBiomarker implements Node {
  alert: Boolean
  alertText: String
  biomarker: Biomarker!
  biomarkerUnit: BiomarkerUnit
  createdAt: DateTime!
  date: DateTime!
  id: ID!
  labTestReport: LabTestReport!
  stringValue: JSONString! @deprecated(reason: "Use value instead")
  updatedAt: DateTime!
  value: GenericScalar!
}

type ProfileBiomarkerConnection {
  edges: [ProfileBiomarkerEdge]!
  pageInfo: PageInfo!
}

type ProfileBiomarkerEdge {
  cursor: String!
  node: ProfileBiomarker
}

type ProfileBiomarkerResult {
  articles(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection
  biomarker: Biomarker!
  results(after: String, before: String, end: Date, first: Int, last: Int, offset: Int, start: Date): ProfileBiomarkerConnection
  supplements(after: String, before: String, first: Int, last: Int, offset: Int): SupplementConnection
}

type ProfileBiomarkers {
  cholesterolLdl: Float
  cortisol: Float
  createdAt: DateTime!
  ferritin: Float
  hba1c: Float
  profile: ProfileType!
  totalCholesterol: Float
  updatedAt: DateTime!
  vitaminB12: Float
  vitaminD: Float
}

input ProfileCustomAttribute {
  category: String
  dataType: AttrDataType!
  name: String!
  timestamp: Float
  value: GenericScalar!
}

enum ProfileField {
  ACTIVITY_LEVEL
  BIOLOGICAL_SEX
  BIRTHDATE
  CUSTOM_ATTRIBUTES
  FAVORITE_CUISINES
  HEIGHT
  RESTRICTIONS
  STARTING_WEIGHT
  TARGET_WEIGHT
  WEEKLY_WEIGHT_GOAL
}

type ProfileMacroGoalsSettings {
  bmi: Int
  bmr: Int
  cd: Int
  dcig: Int
  profile: ProfileType
  success: Boolean
  tdee: Int
}

type ProfileMealPlanSettings {
  success: Boolean
}

enum ProfileMpDiversity {
  HIGH
  LOW
  MEDIUM
}

type ProfileRecommendationType {
  createdAt: DateTime
  databaseId: String
  id: UUID!
  profile: ProfileType!
  recommendation: RecommendationCatalogType
  updatedAt: DateTime
}

type ProfileRestrictionsUpdate {
  message: String!
  restrictions: [ID!]
  success: Boolean!
}

type ProfileType {
  activityLevel: ActivityLevel
  adherenceScore: Float!
  age: Int
  appVersion: String!
  basalMetabolicRate: Int
  biologicalSex: BiologicalSex
  biomarkers: ProfileBiomarkers
  birthdate: Date
  bloodPressureDiastolic: Float
  bloodPressureSystolic: Float
  bodyMassIndex: Float
  caloricDifference: Int
  country: String
  cpcs: [UUID!]!
  createdAt: DateTime
  customAttributes: JSONString
  dailyCaloricIntakeGoal: Int
  debugMealPlanVariables: DebugMealPlanVariables!
  email: String!
  encodedAttributes: String
  extraData: JSONString
  favoriteCuisines: [String!]
  gender: String
  glucoseLevel: Float
  goal: UUID
  goals: [String!]!
  goalsOn: Boolean!
  hasNotifications: Boolean
  hasOnboarded: Boolean!
  height: Float
  id: UUID!
  isImperial: Boolean!
  isPremium: Boolean
  journeyStarted: Boolean
  language: String!
  lat: String
  lon: String
  mealPlan(fromDate: Date): [MealPlanDay!]!
  mpCalories: Int
  mpCarbsPerc: Float
  mpDays: Int
  mpDiversity: ProfileMpDiversity
  mpError: Float
  mpFatPerc: Float
  mpFormat: [String!]!
  mpMonounsaturatedFatPerc: Float
  mpOmega3Perc: Float
  mpPolyunsaturatedFatPerc: Float
  mpProteinPerc: Float
  mpSaturatedFatPerc: Float
  mpTransFatPerc: Float
  program: Program
  programName: String
  restrictions: [Restriction]
  sendbirdAccessToken: String!
  sendbirdId: String!
  startingWeight: Float
  subscription: SubscriptionType
  tags: [String!]
  targetWeight: Float
  thryvePartnerId: String!
  timezone: String!
  totalDailyEnergyExpenditure: Int
  updatedAt: DateTime
  userId: String
  weeklyWeightGoal: WeeklyWeightGoal
  weight: Float
}

type Program implements Node {
  author: String
  authorAvatar: String
  authors: [UUID!]
  backgroundImage: String
  books: JSONString
  comment: String!
  contentlibrarySet(after: String, before: String, first: Int, last: Int, offset: Int): ContentLibraryTypeConnection!
  cover: String
  cpcsIngredientGroups: CPCIngredientGroup
  cpcsRecipeTags: CPCRule
  createdAt: DateTime!
  databaseId: String
  defaultVideoThumnail: String
  descriptionLong: String
  descriptionShort: String
  energyNutrientEquation: ProgramEnergyNutrientEquation!
  id: ID!
  image: String
  isActive: Boolean!
  isPremium: Boolean!
  name: String!
  order: Int!
  productSet(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): ProductTypeConnection!
  restrictions(encoded: Boolean): [String!]!
  showDefaultGoals: Boolean!
  slug: String
  tags: [String!]!
  thirdpartydailyrecapquestionSet(after: String, before: String, first: Int, last: Int, offset: Int): ThirdPartyDailyRecapQuestionConnection!
  transactionSet(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): SubscriptionTransactionConnection!
  visibility: Boolean!
}

type ProgramConnection {
  edges: [ProgramEdge]!
  pageInfo: PageInfo!
}

type ProgramEdge {
  cursor: String!
  node: Program
}

enum ProgramEnergyNutrientEquation {
  HARRIS_BENEDICT
  ONCOLOGY
}

input ProgramOrderBy {
  field: ProgramOrderByField = created_at
  order: SortOrder = ASC
}

enum ProgramOrderByField {
  author
  created_at
  name
}

type Protocol implements Node {
  bundle: Supplement
  createdAt: DateTime!
  group: ProtocolGroup!
  id: ID!
  isActive: Boolean!
  isPublic: Boolean!
  length: Int!
  name: String!
  owner: Coach
  program: Program
  supplementProtocols: [SupplementProtocol!]
  updatedAt: DateTime!
}

type ProtocolConnection {
  edges: [ProtocolEdge]!
  pageInfo: PageInfo!
}

type ProtocolEdge {
  cursor: String!
  node: Protocol
}

enum ProtocolGroup {
  PROTOCOL
  SINGLE_SUPPLEMENT
}

type PublishEvent {
  message: String
  success: Boolean
}

type PurchaseMealRecipe {
  message: String
  success: Boolean
}

type Query {
  appUserActivities(after: String, before: String, coachId: ID!, end: DateTime, filters: AppUserActivityLogFiltersInput, first: Int, last: Int, offset: Int, start: DateTime): ActivityLogConnection
  appointmentCredits: AppointmentCredits!
  appointmentTypes(after: String, before: String, first: Int, last: Int, offset: Int): AppointmentTypeConnection
  articlesRecommended(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): ArticleRecommendedConnection
  assessment(id: ID!): Assessment
  assessments(after: String, before: String, filters: AssessmentsFilterInput, first: Int, last: Int, offset: Int): AssessmentConnection
  autocomplete(after: String, before: String, enter: Boolean, first: Int, last: Int, mealType: MealType, mealTypes: [MealType], query: String): OutoCompleteConnection
  barcodeSearch(barcode: String!): FoodProduct
  biomarkerCatalog(after: String, before: String, filters: BiomarkerFilterInput, first: Int, id: ID, last: Int): BiomarkerConnection
  biomarkerCategories(after: String, before: String, first: Int, id: ID, last: Int, offset: Int, parentId: ID): BiomarkerCategoryConnection
  biomarkerResults(filters: BiomarkerResultsFilterInput): [ProfileBiomarker!]
  biomarkerUnits(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): BiomarkerUnitConnection
  biomarkers(after: String, before: String, filters: BiomarkerFilterInput, first: Int, id: ID, last: Int): BiomarkerConnection
  brandedFoods(after: String, barcode: String, before: String, filter: FoodFilter, first: Int, last: Int, query: String): BrandedFoodConnection
  checkedIntakes(category: IntakeCategory!, end: Date!, start: Date!): DailyChecklist @deprecated(reason: "No longer supported. Use intakesChecklist instead. This query doesn't support supplements on plan")
  coachAvailability(appointmentType: ID!, end: DateTime!, start: DateTime!): [TimePeriod!]!
  coachTeams(after: String, before: String, filters: CoachTeamsFilterInput, first: Int, id: ID, last: Int, offset: Int): CoachTeamConnection
  coachTypes(after: String, before: String, filters: CoachTypesFilterInput, first: Int, id: ID, last: Int, offset: Int): CoachTypeConnection
  commonFoods(after: String, before: String, filter: FoodFilter, first: Int, last: Int, query: String): CommonFoodConnection
  contentCategories(after: String, before: String, first: Int, id: ID, last: Int, offset: Int, tags: [String!]): ContentCategoryTypeConnection
  contentLibrary(after: String, before: String, categories: [ID], first: Int, id: ID, last: Int, offset: Int, order: ContentLibraryOrderBy, search: String, tags: [String!]): ContentLibraryTypeConnection
  contentTags(after: String, before: String, first: Int, last: Int, name: String, offset: Int): ContentTagTypeConnection
  countries: [GenericScalar]
  cuisines(after: String, before: String, first: Int, last: Int, name: String): CuisineConnection
  currentJourneys(after: String, before: String, first: Int, id: UUID, journeyId: ID, last: Int, offset: Int): JourneyProfileTypeConnection
  customMealPlan(breakfastDistribution: Float, calories: Int!, carbs: Float, days: Int, dinnerDistribution: Float, error: Float, fat: Float, format: [MealTime]!, lunchDistribution: Float, maxIngredientsCount: IntValueByMealTime, maxTimeMinutes: IntValueByMealTime, omega3: Float, program: ID, protein: Float, skipRecipes: [ID!], snackDistribution: Float): [MealPlanDay]
  dailyMoodSummary(endDate: Date!, startDate: Date!): DailyMoodSummary!
  dailyRecap(date: Date!, group: GroupQuestion): [DailyQuestion!]!
  dailyRecapQuestions(group: GroupQuestion): [DailyQuestion!]!
  dailyRecaps(endDate: Date!, group: GroupQuestion, startDate: Date!): [DailyRecap!]!
  dashboard: Dashboard
  drugNutrientInteractions(after: String, before: String, filters: DrugNutrientInteractionsFilterInput, first: Int, last: Int, offset: Int): DrugGroupConnection
  exerciseTracker(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): ExerciseEntriesConnection!
  featureLimitations: [AppRestriction!]!
  featuredRecipesByProgram(programId: String): [Recipe]
  foodLog(id: ID!): MealLog
  foodLogAssistant(userInput: String!): FoodLogAssistant
  foodLogs(after: String, end: Date!, first: Int, id: ID, start: Date!): FoodLogConnection!
  foodLogsByUser(after: String, before: String, first: Int, fromDate: Date!, last: Int, toDate: Date!, userId: String!): MealLogConnection
  frequentMealLogs: [MealLog]
  googleTransaction(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): GooglePlayTransactionTypeConnection
  heartRateLogs(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): HeartRateLogsConnnection!
  historicalBiomarkerResults(after: String, before: String, filters: HistoricalBiomarkerResultsFilterInput, first: Int, last: Int, offset: Int): ProfileBiomarkerConnection
  historicalResultsByBiomarker(id: ID!): ProfileBiomarkerResult
  hrvLogs(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): HrvLogsConnnection!
  hydration(endDate: Date!, source: SourceType, startDate: Date!, toMl: Boolean): [Hydration!]!
  ingredientSearch(after: String, before: String, first: Int, last: Int, query: String = "Query search term"): IngredientSearchResultConnection
  intakesChecklist(category: IntakeCategory!, end: Date!, start: Date!): IntakesChecklist
  isUserProgramStarted: Boolean
  labTestReports(after: String, before: String, first: Int, id: ID, isVisible: Boolean, last: Int, profile: ID): LabTestReportConnection
  locationAutocomplete(lat: Float!, lon: Float!, query: String!): [LocationAutocomplete]
  log(id: ID!): Logger
  logs(after: String, before: String, first: Int, last: Int, sortBy: SortBy, sortOrder: SortOrder, user: String): LoggerConnection
  macroGoals(date: Date!): MacroGoals
  mealLog(after: String, before: String, first: Int, fromDate: Date!, last: Int, toDate: Date!): MealLogConnection
  mealLogMacroAggs(fromDate: Date!, toDate: Date!): MealLogMacroAggs
  mealPlan(fromDate: Date): [MealPlanDay]
  mealPlanTemplate(id: ID!): MealPlanTemplate
  mealPlanTemplates(after: String, before: String, byCoach: ID, coachTypes: [ID!], excludeCoach: ID, first: Int, isPublic: Boolean, last: Int, newerFirst: Boolean, offset: Int, search: String): MealPlanTemplateConnection
  mealPlannerByCustomFormat(format: [MealTime]!): MealCustomPlannerDays
  mealPlannerByDay(mealPlannerQueryType: MealPlannerQueryType!): MealPlannerDays
  mealTracker(endDate: Date!, startDate: Date!): [MealTrack]!
  menuitem(id: ID!): MenuItem
  menuitemByProgram(databaseId: String!, programId: String!): MenuItem
  menuitemMealTags: [String]
  menuitemSearch(after: String, before: String, course: String, first: Int, last: Int, meals: [String], menu: String, query: String, restaurantId: String, tags: [String]): MenuItemConnection
  menuitemTags: [String]
  menuitems(restaurantId: String!): [MenuItem]
  menuitemsByProgram(programId: String!, restaurantId: String!): [MenuItem]
  myAppointments(end: DateTime, start: DateTime, timezone: String): [Appointment!]!
  myBrandedFoods(after: String, before: String, first: Int, id: String, last: Int): MyBrandedFoodConnection
  myChecklistItems(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): MyChecklistItemConnection
  myChecklistLogs(end: Date!, start: Date!): MyChecklistLogs!
  myCoaches(after: String, before: String, excludeAppointmentCoaches: Boolean = false, first: Int, id: ID, last: Int, offset: Int): CoachConnection
  myCommonFoods(after: String, before: String, first: Int, id: String, last: Int): MyCommonFoodConnection
  myFavoriteArticles(after: String, before: String, categories: [ID], first: Int, last: Int, offset: Int, order: ContentLibraryOrderBy, search: String, tags: [String!]): ContentLibraryTypeConnection
  myFavoriteMenuitems(after: String, before: String, first: Int, last: Int): MenuItemConnection
  myFavoriteRecipes(after: String, before: String, first: Int, last: Int): RecipeConnection
  myFavoriteRestaurants(after: String, before: String, first: Int, last: Int): RestaurantConnection
  myProfile: ProfileType
  myRecipes(after: String, before: String, first: Int, id: ID, last: Int): UserRecipeConnection
  nextIntakes(category: IntakeCategory!): IntakesChecklistDay
  notes(after: String, before: String, eventId: ID, first: Int, id: ID, last: Int, offset: Int): NoteConnection
  nutrientAggregationsByFoodLog(fromDate: Date!, toDate: Date!): NutrientAggregationsByFoodLog
  onProgramPopularRestaurants(lat: Float!, lon: Float!): [Restaurant]
  outocomplete(after: String, before: String, enter: Boolean, first: Int, last: Int, mealType: MealType, mealTypes: [MealType], query: String): OutoCompleteConnection @deprecated(reason: "Deprecating soon.")
  ownFoodItem(id: ID!): MealLog
  ownFoodItems(after: String, before: String, first: Int, fromDate: Date, last: Int, toDate: Date): MealLogConnection
  ownMealLog(id: ID!): MealLog
  ownMealLogs: [MealLog]
  ownRecipe(id: ID!): MealLog
  ownRecipes(after: String, before: String, first: Int, fromDate: Date, last: Int, toDate: Date): MealLogConnection
  popularRecipes(after: String, before: String, cuisines: [String], first: Int, hidePurchasable: Boolean = true, last: Int): RecipeConnection
  premiumProgramRecipes(after: String, before: String, first: Int, last: Int): RecipeConnection
  profileRecommendations: [ProfileRecommendationType]
  program(id: ID!): Program
  programs(after: String, before: String, first: Int, isActive: Boolean, isPremium: Boolean, last: Int, offset: Int, orderBy: ProgramOrderBy): ProgramConnection
  purchases: UserPurchases
  question(id: ID!): AssessmentQuestion
  questions(after: String, before: String, filters: QuestionsFilterInput, first: Int, last: Int, offset: Int): AssessmentQuestionConnection
  quizAnswers: [QuizAnswer!]!
  quizPrograms: [QuizProgram]
  recentMealLogs: [MealLog]
  recipe(id: ID!): Recipe
  recipeMealTags: [String]
  recipeSearch(after: String, before: String, cuisines: [String], dietaryTag: DietaryTag, filter: FoodFilter, first: Int, hasImage: Boolean, hasInstructions: Boolean, ingredients: [String], isPremium: Boolean, last: Int, macroNutrientsRange: MacroNutrientsRangeInput, maxPrepTime: Int, mealTime: RecipeMealTime, meals: [String], minPrepTime: Int, numberOfIngredients: Int, program: String, query: String, servingQuantity: Int, skillLevel: SkillLevel, tags: [String], totalTime: Float): RecipeConnection
  recipeSwapOptions(recipeId: String, serving: Int): RecipeSwapOptions
  recipeTags(after: String, before: String, first: Int, last: Int, name: String, offset: Int): RecipeTagConnection
  recipesByMealTime(after: String, before: String, cuisines: [String], dietaryTags: [DietaryTag], first: Int, hidePurchasable: Boolean = true, last: Int, maxPrepTime: Int, mealTime: RecipeMealTime): RecipeConnection
  recipesByTag(after: String, before: String, dietaryTags: [DietaryTag], first: Int, hidePurchasable: Boolean = true, last: Int, maxPrepTime: Int, tag: String): RecipeConnection
  recommendedMenuitems(lat: Float!, lon: Float!): [MenuItem]
  recommendedSwaps(forSimpleMealPlan: Boolean, mealTime: RecipeMealTime!): RecommendedSwaps
  restaurant(id: ID!): Restaurant
  restaurantAutocomplete(lat: Float!, lon: Float!, query: String!): [Restaurant]
  restaurantRecommendedMenuitems(restaurantId: String!): [MenuItem]
  restaurantSearch(address: String, after: String, before: String, cuisines: [String], distance: Int = 3, first: Int, geoBoundingBox: GeoBoundingBox, gotAr: Boolean, isOpen: Boolean, last: Int, lat: Float, lon: Float, postalCode: String, priceRating: [PriceRate], program: String, query: String, stateProvince: String): RestaurantConnection
  restaurantSearchByLocation(cuisine: String, geoBoundingBox: GeoBoundingBox, geolat: Float, geolon: Float, lat: Float!, lon: Float!, query: String): RestaurantSearchResult
  restaurantsByLocation(after: String, before: String, first: Int, last: Int, lat: Float, lon: Float): RestaurantConnection
  restriction(id: ID!): Restriction
  restrictions(after: String, before: String, first: Int, last: Int): RestrictionConnection
  searchProfile(email: String!): ProfileType
  searchRecipeByNameOrIngredient(query: String): RecipeSearchResult
  searchRecipesByIngredients(after: String, before: String, first: Int, last: Int, mustIngredients: [String]!): RecipeConnection
  serchForAllowedIngredient(ingredient: String!): [CPCIngredient]
  shoppingList(after: String, before: String, first: Int, last: Int, offset: Int, recipe: ID): ListItemConnection
  shoppingListAggregate(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): AggregateConnection
  shoppingListBadge: Boolean
  similarMacrosRecipes(recipeId: String, serving: Int, size: Int): [Recipe]
  sleepQualityScores(after: String, end: Date!, first: Int, id: ID, source: SourceType, start: Date!): SleepQualityScoresConnnection!
  sleepTimes(after: String, end: Date!, first: Int, id: ID, source: SourceType, start: Date!): SleepTimesConnnection!
  stepsCounter(after: String, end: DateTime!, first: Int, id: ID, source: SourceType, start: DateTime!): StepsCounterConnection!
  streaks(endDate: Date!, source: SourceType, startDate: Date!): [Streak!]!
  streaksStats(endDate: Date!, source: SourceType, startDate: Date!): StreaksStats!
  subscriptions(after: String, before: String, first: Int, id: UUID, last: Int, offset: Int): SubscriptionTypeConnection
  suggestMeal(date: Date!, mealTime: MealTime!): SuggestedMeal
  suggestedMeals(date: Date!): SuggestedMeals
  supplement(id: ID!): Supplement
  supplementParent(supplementId: ID!): SupplementParent
  supplementPlans(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): SupplementPlanConnection
  supplements(after: String, before: String, first: Int, id: ID, last: Int, name: String, offset: Int): SupplementConnection
  supplementsRecommended(after: String, before: String, first: Int, id: ID, last: Int, offset: Int): SupplementRecommendedConnection
  thirdPartyAppsCustomizations: ThirdPartyAppCustomization
  thirdPartyDailyRecapAnswers(answer: String, answerType: String): [DailyRecapAnswer!]
  thirdPartyDailyRecapQuestions(after: String, answers: [ID!], before: String, first: Int, last: Int, offset: Int, question: String): ThirdPartyDailyRecapQuestionConnection
  todayFoods(endDate: Date!, startDate: Date!): Checklist @deprecated(reason: "No longer supported. Use intakesChecklist instead")
  todaySupplements(endDate: Date!, startDate: Date!): Checklist @deprecated(reason: "No longer supported. Use intakesChecklist instead")
  trackingDailyGoals: TrackingDailyGoals!
  trackingSources: [ConnectedSource!]!
  trendingRecipes(after: String, before: String, first: Int, last: Int): RecipeConnection
  usdaFoodByNdbNumber(ndbNumber: String): UsdaFood
  userAnswersByAssessment(id: ID!): Assessment
  userAssessment(assessmentId: ID!): Assessment
  userAssessments(after: String, before: String, filters: UserAssessmentsFilterInput, first: Int, last: Int, offset: Int): AssessmentConnection
  users(after: String, before: String, first: Int, last: Int, offset: Int, profileUUIDs: [String!], subscriptionId: ID, userUUIDs: [String!]): UserConnection
  usersProgress(after: String, before: String, filters: UsersProgressFilterInput, first: Int, last: Int, offset: Int): UserProgressConnection
  weightTracker(endDate: Date!, source: SourceType, startDate: Date!): WeightTracker
}

enum QuestionProfileField {
  ACTIVITY_LEVEL
  BIOLOGICAL_SEX
  BIRTHDATE
  CUSTOM_ATTRIBUTES
  FAVORITE_CUISINES
  HEIGHT
  RESTRICTIONS
  STARTING_WEIGHT
  TARGET_WEIGHT
  WEEKLY_WEIGHT_GOAL
}

enum QuestionType {
  DATE_PICKER
  DROPDOWN
  MULTI_SELECT
  OPEN_NUMBER
  OPEN_TEXT
  SINGLE_SELECT
  TIME_PICKER
}

input QuestionsFilterInput {
  assessmentId: ID
  canSkip: Boolean
  questionType: QuestionType
  text: String
}

type QuizAnswer {
  answer: String!
  answerImage: String
  id: ID!
  question: String!
  questionImage: String
  timestamp: DateTime!
}

type QuizInfo {
  isActive: Boolean
  label: String
}

type QuizProgram {
  author: String
  authorAvatar: String
  backgroundImage: String
  description: String
  experience: QuizInfo
  health: QuizInfo
  isPremium: String
  name: String
  preferences: QuizInfo
  programId: String
}

input Range {
  gte: Float!
  lte: Float!
}

input RangeByMealTimeInput {
  breakfast: RangeInput
  dinner: RangeInput
  lunch: RangeInput
  snack: RangeInput
}

input RangeFilter {
  gte: Float
  lte: Float
}

input RangeInput {
  max: Int
  min: Int
}

input RangeOperator {
  gt: Float
  gte: Float
  lt: Float
  lte: Float
}

type RawNutrientsFull {
  cholesterol: Float
  energy: Float
  fiber: Float
  potassiumK: Float
  saturatedFat: Float
  sodiumNa: Float
  transFats: Float
}

type Recipe implements Node {
  adherence: Float @deprecated(reason: "Not used, will be removed")
  adherenceDetails: Adherence
  author: String
  authorAvatar: String
  authors: String @deprecated(reason: "Use author instead of this")
  caloriesPerServing: CaloriesPerServing
  cleanName: String
  completeNutritionEstimates: GenericScalar @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  course: String @deprecated(reason: "Use courses instead")
  courses: [String]
  cuisine: String @deprecated(reason: "Use cuisines instead")
  cuisines: [String]
  databaseId: String
  datasetType: String @deprecated(reason: "Not used, internal use only")
  externalId: String
  favoritesCount: Int
  hasTrainableIngredients: Boolean
  id: ID!
  inUserShoppingList: Boolean
  indexedAt: DateTime
  ingredientLines: [String]
  ingredients: [Ingredient]
  ingredientsCount: Int
  instructions: [String]
  isActive: Boolean
  isFeatured: Boolean
  isIndexed: Boolean @deprecated(reason: "Not used, will be removed")
  isLogged: Boolean
  isPremium: Boolean
  isPurchasable: Boolean
  isRestricted: Boolean
  isUserFavorite: Boolean
  language: String
  logo: String
  mainImage: String
  mealBalanceIndex: MealBalanceIndexScore
  mealTags: [String]
  name: String
  nameLowercase: String @deprecated(reason: "Not used, will be removed")
  numberOfServings: Int
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsFull: RawNutrientsFull @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsPerServing: NutrientsPerServing
  nutritionEstimates: NutritionEstimates @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutritionalInfo: NutritionalInfo
  parsedIngredientLines(preferredUnitSystem: UnitSystem): [IngredientLine] @deprecated(reason: "Not used, will be removed")
  programIds: [String]
  rating: Int
  recipeType: String
  relativeCalories: RelativeCalories
  serving: Int
  servingWeight: Float
  servings: [Servings] @deprecated(reason: "Not used, will be removed")
  sgCuisines: [String]
  sgScores: SgScores @deprecated(reason: "Not used, internal use only")
  sgValidated: Boolean
  source: Source
  sourceUrl: String @deprecated(reason: "Use Source.recipeUrl instead")
  sourceUrlNotWorks: Boolean @deprecated(reason: "Not used, will be removed")
  sourceUrlWorks: Boolean!
  squareImage: String
  syntaxIngs: [String]
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
  updatedAt: DateTime
  url: String @deprecated(reason: "Use Source.recipeUrl instead")
  usersFavorite: [String]
  usersShoppingList: [String]
  weightInGrams: Float
  yieldText: String
}

type RecipeConnection {
  edges: [RecipeEdge]!
  pageInfo: PageInfo!
}

type RecipeEdge {
  cursor: String!
  node: Recipe
}

enum RecipeMealTime {
  BREAKFAST
  DINNER
  LUNCH
  SNACK
  TREAT_DESSERT
}

type RecipeProxy {
  recipe: Recipe!
}

type RecipeSearchResult {
  onPlan: [Recipe]
  otherResults: [Recipe]
}

type RecipeSwapOptions {
  onPlan(size: Int): [Recipe]
  similar(size: Int): [Recipe]
}

type RecipeTag implements Node {
  createdAt: DateTime!
  displayName: String!
  id: ID!
  termName: String!
  updatedAt: DateTime!
}

type RecipeTagConnection {
  edges: [RecipeTagEdge]!
  pageInfo: PageInfo!
}

type RecipeTagEdge {
  cursor: String!
  node: RecipeTag
}

type RecommendationCatalogType {
  createdAt: DateTime
  databaseId: String
  id: UUID!
  image: String
  profilerecommendationSet: [ProfileRecommendationType!]!
  reference: String!
  subtitle: String
  textAdditional1: String
  textAdditional2: String
  textMain: String
  title: String!
  updatedAt: DateTime
  url: String
}

type RecommendedSwaps {
  meals: [Recipe]
  recipes: [Recipe]
}

type RelativeCalories {
  ala: Float
  carbs: Float
  dha: Float
  dpa: Float
  epa: Float
  fat: Float
  monounsaturatedFat: Float
  omega3: Float
  polyunsaturatedFat: Float
  protein: Float
  saturatedFat: Float
  transFat: Float
}

type RemoveFavoriteArticle {
  message: String!
  success: Boolean!
}

type RemoveFromShoppingList {
  success: Boolean
}

type RemoveMealLogMutation {
  success: Boolean
}

type RemoveMealPlan {
  message: String
  success: Boolean
}

type RemoveMealPlanRecipe {
  message: String!
  success: Boolean!
}

type RemoveOwnMeal {
  success: Boolean
}

type RequestAccountDeletion {
  message: String!
  success: Boolean!
}

type RequestResetPassword {
  message: String!
  resetPasswordCode: String
  success: Boolean!
}

type ResendAppointmentConfirmationEmail {
  message: String!
  success: Boolean!
}

type ResetPassword {
  message: String!
  success: Boolean!
}

type Restaurant implements Node {
  address1: String
  businessType: String
  cityTown: String
  country: String
  createdAt: DateTime
  cuisine: String @deprecated(reason: "Use cuisines instead of cuisine")
  cuisineTag: String @deprecated(reason: "Use cuisines instead of cuisine_tag")
  cuisines: [String]
  databaseId: String
  description: String
  favoritesCount: Int
  gotAr: Boolean
  hours: Hours
  id: ID!
  indexedAt: DateTime
  isActive: Boolean
  isClosed: Boolean
  isOpen: Boolean
  isOwnerVerified: Boolean
  isRecomended: Boolean
  isUserFavorite: Boolean
  location: [Float]
  locationId: String
  maxPriceRange: Float @deprecated(reason: "no longer used")
  minPriceRange: Float @deprecated(reason: "no longer used")
  name: String
  phone: String
  photos: [String]
  postalCode: String
  priceRating: String
  recommendation: String
  recommendationsCount: Int
  shortName: String
  stateProvince: String
  suggest: String
  type: String
  updatedAt: DateTime
  usersFavorite: [String]
  websiteUrl: String
  yelpRating: Float
  yelpReviewCount: Int
}

type RestaurantConnection {
  edges: [RestaurantEdge]!
  pageInfo: PageInfo!
  totalCount: Int
}

type RestaurantEdge {
  cursor: String!
  node: Restaurant
  other: String
}

type RestaurantSearchResult {
  onPlan: [Restaurant]
  otherResults: [Restaurant]
}

type Restriction implements Node {
  databaseId: String @deprecated(reason: "use ID!")
  id: ID!
  isOnProgram: Boolean
  name: String
  slugname: String
  subcategory: String
}

type RestrictionConnection {
  edges: [RestrictionEdge]!
  pageInfo: PageInfo!
}

type RestrictionEdge {
  cursor: String!
  node: Restriction
}

input SPProtocolInput {
  directionsOfUse: [DirectionsOfUseInput!]!
  friday: Boolean
  isActive: Boolean
  monday: Boolean
  protocolId: ID!
  saturday: Boolean
  sunday: Boolean
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

input SPUpdateProtocolInput {
  directionsOfUse: [DirectionsOfUseInput!]
  friday: Boolean
  isActive: Boolean
  monday: Boolean
  protocolId: ID!
  saturday: Boolean
  sunday: Boolean
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

type SelectDailyRecapQuestions {
  message: String!
  success: Boolean!
}

type SendFeedback {
  message: String
  success: Boolean
}

type SensitiveProfileAttributes {
  errors: [ErrorType]
  success: Boolean
}

type Servings {
  amount: Float
  description: String
  equivalent: Float
  selected: Boolean
  unit: String
}

type SetActiveSource {
  message: String!
  success: Boolean!
}

type SetMealPlanToTemplate {
  message: String!
  success: Boolean!
}

type SetUserAnswers {
  errors: [FormError!]
  message: String!
  success: Boolean!
  userAnswers: [UserAnswer!]
}

input SetUserAnswersInput {
  assessmentId: ID!
  userAnswers: [UserAnswerInput!]!
}

type SgScores {
  keto: Float
}

input SimpleMPFiltersInput {
  cuisines: [String]
  kcalRange: RangeByMealTimeInput
  tags: TermValuesByMealTimeInput
}

input SingleSupplementActivableProtocolInput {
  directionsOfUse: [DirectionsOfUseInput!]
  friday: Boolean
  isActive: Boolean
  length: Int!
  monday: Boolean
  saturday: Boolean
  sunday: Boolean
  supplementId: ID!
  thursday: Boolean
  tuesday: Boolean
  wednesday: Boolean
}

enum SkillLevel {
  EASY
  EXPERT
  MEDIUM
}

input SleepQualityEntryInput {
  date: Date!
  source: SourceType!
  value: PositiveInt!
}

type SleepQualityScore {
  date: Date!
  id: ID!
  source: SourceType!
  value: Int!
}

type SleepQualityScoreEdge {
  cursor: String!
  node: SleepQualityScore
}

type SleepQualityScoresConnnection {
  average: Int!
  edges: [SleepQualityScoreEdge]!
  pageInfo: PageInfo!
}

type SleepTime {
  createdAt: DateTime!
  date: Date!
  id: ID!
  source: SourceType!
  value: Int!
}

type SleepTimeEdge {
  cursor: String!
  node: SleepTime
}

input SleepTimeEntryInput {
  date: Date!
  source: SourceType!
  value: PositiveInt!
}

type SleepTimesConnnection {
  dailyGoal: Int!
  edges: [SleepTimeEdge]!
  latestEntry: DateTime
  pageInfo: PageInfo!
  totalTime: Int!
}

enum SortBy {
  INDEXED_AT
}

enum SortOrder {
  ASC
  DESC
}

type Source {
  displayName: String
  recipeUrl: String!
  siteUrl: String
}

enum SourceType {
  APPLE
  FITBIT
  GARMIN
  GOOGLEFIT_NATIVE
  GOOGLEFIT_REST
  HUAWEIHEALTH
  IHEALTH
  MISFIT
  OMRONCONNECT
  OMRONWELLNESS
  OURA
  POLAR
  SAMSUNG
  STRAVA
  SUGGESTIC
  SUUNTO
  WITHINGS
}

type StartJourneys {
  message: String
  success: Boolean
}

type StartOverMealPlan {
  message: String
  success: Boolean
}

type StepCount {
  createdAt: DateTime!
  datetime: DateTime!
  id: ID!
  source: SourceType!
  steps: Int!
}

input StepCountEntryInput {
  datetime: DateTime!
  source: SourceType!
  steps: PositiveInt!
}

type StepsCounterConnection {
  dailyGoal: Int!
  distance: Float!
  edges: [StepsCounterEdge]!
  latestEntry: DateTime
  pageInfo: PageInfo!
}

type StepsCounterEdge {
  cursor: String!
  node: StepCount
}

type Streak {
  activities: [EntryType] @deprecated
  completed: [EntryType]
  date: Date
  dayStatus: DayStatus
  empties: [EntryType]
  expectedActivities: [EntryType]
  hasPreviousStreak: Boolean
  isToday: Boolean
  longestStreakEver: Int! @deprecated
  totalPerfectDays: Int! @deprecated
}

type StreaksStats {
  longestStreak: Int!
  totalPerfectDays: Int!
}

enum SubscriptionBillingPeriod {
  MONTH
  ONCE
  SEMESTER
  TRI_MONTH
  YEAR
}

enum SubscriptionDuration {
  FOREVER
  MONTH
  SEMESTER
  TRI_MONTH
  YEAR
}

type SubscriptionTransaction implements Node {
  cancellationDate: DateTime
  cancellationSource: String
  createdAt: DateTime
  email: String
  expirationDate: DateTime
  expiresStat: String
  externalTransactionId: String
  hasRefund: Boolean!
  id: ID!
  isActive: Boolean!
  isCanceled: Boolean!
  isDowngrade: Boolean!
  isExpired: Boolean
  isInitial: Boolean!
  isProcess: Boolean!
  isRenewal: Boolean!
  isTrialPeriod: Boolean!
  livemode: Boolean!
  parentId: String
  parentType: String
  program: Program
  programStat: String
  purchaseDate: DateTime
  subscription: SubscriptionType
  transactionProvider: String!
  updatedAt: DateTime
}

type SubscriptionTransactionConnection {
  edges: [SubscriptionTransactionEdge]!
  pageInfo: PageInfo!
}

type SubscriptionTransactionEdge {
  cursor: String!
  node: SubscriptionTransaction
}

type SubscriptionType implements Node {
  appleId: String
  billingPeriod: SubscriptionBillingPeriod
  createdAt: DateTime
  databaseId: String
  duration: SubscriptionDuration!
  googleplaySku: String
  id: ID!
  isActive: Boolean!
  isRecurring: Boolean!
  name: String!
  periodPrice: Int!
  permissions: [String!]
  product: ProductType
  totalPrice: Int!
  trialPeriodDays: Int!
  updatedAt: DateTime
}

type SubscriptionTypeConnection {
  edges: [SubscriptionTypeEdge]!
  pageInfo: PageInfo!
}

type SubscriptionTypeEdge {
  cursor: String!
  node: SubscriptionType
}

type SuggestedMeal {
  databaseId: String
  isLogged: Boolean
  loggedDatabaseId: String
  mainImage: String
  mealTime: MealTime
  mealType: MealType
  name: String
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo or nutrientsPerServing instead")
  nutrientsPerServing: NutrientsPerServing
  nutritionalInfo: NutritionalInfo
  recipeType: String
  squareImage: String
}

type SuggestedMeals {
  breakfast: SuggestedMeal
  dinner: SuggestedMeal
  lunch: SuggestedMeal
  snack: SuggestedMeal
}

type Suggestion {
  author: String
  barcode: String
  brand: String
  courses: [String]
  databaseId: String
  extraInfo: String
  foodBlockOrManufacturer: String
  indexedAt: DateTime
  isRawIngredient: Boolean
  isVerified: Boolean
  location: GeoPoint
  manufacName: String
  mealType: MealType
  mealTypeDisplayName: String
  name: String
  nutrients: Nutrients @deprecated(reason: "Use nutritionalInfo instead")
  nutritionalInfo: NutritionalInfo
  profileId: String
  secondaryInfoText: String
  serving: Int
  servingWeight: Float
  servings: [Servings]
  suggest: String
  unitOption: String
  updatedAt: DateTime
}

type Supplement implements Node {
  brand: String!
  category: String!
  createdAt: DateTime!
  description: String
  directionsOfUse: [SupplementDirection!]!
  directionsOfUseText: String
  externalId: String
  id: ID!
  images: [String!]
  ingredients: String
  instructions: String
  mainImage: String!
  name: String!
  protocolBundle(after: String, before: String, first: Int, last: Int, offset: Int): ProtocolConnection!
  servingName: String!
  shopifyParentId: String
  shopifyVariantId: String
  sizeCount: Int!
  sku: String
  storeId: String
  supplementFacts: String
  supplementrecommendationSet(after: String, before: String, first: Int, last: Int, offset: Int): SupplementRecommendedConnection!
  updatedAt: DateTime!
}

input SupplementCartItem {
  quantity: Int!
  variantId: ID!
}

type SupplementConnection {
  edges: [SupplementEdge]!
  pageInfo: PageInfo!
}

type SupplementDirection {
  createdAt: DateTime!
  id: ID!
  quantity: Float!
  timeOfDay: TimeOfDay!
  updatedAt: DateTime!
}

type SupplementEdge {
  cursor: String!
  node: Supplement
}

type SupplementOnPlan {
  checked: Boolean!
  order: Int!
  planName: String!
  quantity: Float!
  supplement: Supplement!
  timeOfDay: TimeOfDay
}

type SupplementParent {
  availableForSale: Boolean!
  featuredImage: String
  id: ID!
  options: [ProductOption!]
  title: String!
  variants: [ProductVariant!]!
}

type SupplementPlan implements Node {
  createdAt: DateTime!
  exercise: String
  id: ID!
  isActive: Boolean!
  name: String!
  nutrition: String
  overview: String
  protocols(coachTypes: [ID!], group: ProtocolGroup): [SupplementPlanProtocol!]!
  resources: String
  startDate: Date!
  updatedAt: DateTime!
  visibility: Boolean!
}

type SupplementPlanConnection {
  edges: [SupplementPlanEdge]!
  pageInfo: PageInfo!
}

type SupplementPlanEdge {
  cursor: String!
  node: SupplementPlan
}

type SupplementPlanProtocol {
  createdAt: DateTime!
  directionsOfUse: [SupplementDirection!]!
  endsAt: DateTime
  friday: Boolean!
  id: ID!
  isActive: Boolean!
  monday: Boolean!
  order: Int!
  protocol: Protocol!
  saturday: Boolean!
  startsAt: DateTime
  sunday: Boolean!
  thursday: Boolean!
  tuesday: Boolean!
  updatedAt: DateTime!
  wednesday: Boolean!
}

type SupplementProtocol {
  directionsOfUse: [SupplementDirection!]!
  friday: Boolean!
  id: ID!
  monday: Boolean!
  saturday: Boolean!
  sunday: Boolean!
  supplement: Supplement!
  thursday: Boolean!
  tuesday: Boolean!
  wednesday: Boolean!
}

type SupplementRecommended implements Node {
  biomarker: Biomarker!
  createdAt: DateTime!
  id: ID!
  normalValues: [GenericScalar!]
  supplement: Supplement!
  updatedAt: DateTime!
  valueMax: Float
  valueMin: Float
}

type SupplementRecommendedConnection {
  edges: [SupplementRecommendedEdge]!
  pageInfo: PageInfo!
}

type SupplementRecommendedEdge {
  cursor: String!
  node: SupplementRecommended
}

type SwapMealPlanRecipe {
  mealPlan: [MealPlanDay] @deprecated(reason: "Not used, will be removed")
  message: String
  success: Boolean
}

type TaskItemType {
  id: ID!
  isCompleted: Boolean
  keyHash: String
  name: String
  taskListId: String
}

type TaskListType {
  databaseId: String
  id: ID!
  name: String!
  taskItems: [TaskItemType]
}

type Tendency {
  difference: Float
  type: TendencyType
}

enum TendencyType {
  DOWN
  UP
}

input TermValuesByMealTimeInput {
  breakfast: [String!]
  dinner: [String!]
  lunch: [String!]
  snack: [String!]
}

type ThirdPartyAppCustomization implements Node {
  backgroundGradientColor1: String
  backgroundGradientColor2: String
  id: ID!
  logo: String
  primaryColor: String
  secondaryColor: String
  selectedFeatures: [String!]!
}

type ThirdPartyDailyRecapQuestion implements Node {
  answers: [DailyRecapAnswer!]
  group: String
  id: ID!
  imageUrl: String
  isDefault: Boolean
  lang: JSONString!
  program: Program
  question: String
  title: String
}

type ThirdPartyDailyRecapQuestionConnection {
  edges: [ThirdPartyDailyRecapQuestionEdge]!
  pageInfo: PageInfo!
}

type ThirdPartyDailyRecapQuestionEdge {
  cursor: String!
  node: ThirdPartyDailyRecapQuestion
}

scalar Time

enum TimeOfDay {
  AT_BEDTIME
  AT_WAKING
  WITH_BREAKFAST
  WITH_DINNER
  WITH_LUNCH
}

type TimePeriod {
  coaches: [Coach!]!
  end: DateTime!
  start: DateTime!
}

type ToggleShoppingListItem {
  message: String
  success: Boolean
}

type ToggleTaskCompleted {
  message: String
  success: Boolean
}

enum TrackerComponent {
  DAILY_MOOD
  DAILY_RECAP
  EXERCISE_TRACKER
  FOOD_LOGS
  FOOD_LOG_MEAL_TRACKER
  HEART_RATE_TRACKER
  HRV_TRACKER
  HYDRATION_TRACKER
  MP_MEAL_TRACKER
  MY_CHECKLIST_TRACKER
  PLAN_SUPPLEMENT
  PLAN_SUPPLEMENTS_MY_CHECKLIST
  SLEEP_QUALITY_SCORE_TRACKER
  SLEEP_TIME_TRACKER
  STEPS_TRACKER
  TODAY_FOOD
  TODAY_SUPPLEMENT
  WEIGHT_TRACKER
}

type TrackingDailyGoal {
  entryType: EntryType!
  goal: Int
}

type TrackingDailyGoals {
  dailyGoals: [TrackingDailyGoal!]!
}

scalar UUID

type UncheckIntake {
  message: String!
  success: Boolean!
}

type UncheckTodayFood {
  message: String!
  success: Boolean!
}

type UncheckTodaySupplement {
  message: String!
  success: Boolean!
}

enum UnitSystem {
  IMPERIAL
  METRIC
}

type UnlinkUserAssessment {
  message: String!
  success: Boolean!
}

type UpdateAnswer {
  answer: AssessmentAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateAnswerInput {
  attribute: AttributeInput
  id: ID!
  isCorrect: Boolean
  nextQuestionId: ID
  score: Int
  text: String
}

type UpdateAppointment {
  appointment: Appointment
  message: String!
  success: Boolean!
}

type UpdateAppointmentCredits {
  credits: AppointmentCredit
  message: String!
  success: Boolean!
}

input UpdateAppointmentInput {
  appointment: ID!
  appointmentType: ID
  contactType: CalendarContactType
  datetime: DateTime
  timezone: String
}

type UpdateArticleRecommended {
  articleRecommended: ArticleRecommended
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateArticleRecommendedInput {
  articleId: ID
  biomarkerId: ID
  id: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
}

type UpdateAssessment {
  assessment: Assessment
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateAssessmentInput {
  assessmentType: AssessmentType
  description: String
  icon: Upload
  id: ID!
  interval: Int
  isDraft: Boolean
  isPublic: Boolean
  order: Int
  progressBar: Boolean
  title: String
  weight: Int
}

type UpdateBiomarker {
  biomarker: Biomarker
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type UpdateBiomarkerCategory {
  biomarkerCategory: BiomarkerCategory
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateBiomarkerCategoryInput {
  id: ID!
  name: String
  parent: ID
}

input UpdateBiomarkerInput {
  aliases: [BiomarkerAliasInput!]
  borderlineRange: BiomarkerRangeInput
  category: ID
  description: String
  id: ID!
  isVisible: Boolean = true
  method: String
  name: String
  normalValues: [GenericScalar!] = ["{}"]
  optimalRange: BiomarkerRangeInput
  order: Int = 0
  range: BiomarkerRangeInput
  units: [ID!]
}

type UpdateCoachTeam {
  coachTeam: CoachTeam
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateCoachTeamInput {
  coaches: [ID!]
  description: String
  id: ID!
  name: String
}

type UpdateCoachType {
  coachType: CoachType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateCoachTypeInput {
  coaches: [ID!]
  description: String
  id: ID!
  name: String
}

type UpdateContentCategory {
  contentCategory: ContentCategoryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateContentCategoryInput {
  id: ID!
  image: Upload
  lang: GenericScalar
  name: String
  order: Int
  subcategories: [ID]
  tags: [ID]
}

type UpdateContentLibrary {
  contentLibrary: ContentLibraryType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateContentLibraryInput {
  categories: [ID]
  id: ID!
  imageUrl: String
  isBlocked: Boolean
  isFeatured: Boolean
  lang: GenericScalar = "{}"
  order: Int
  programs: [ID!]
  sourceUrl: String
  subTitle: String
  tags: [ID]
  title: String
}

type UpdateContentTag {
  contentTag: ContentTagType
  errors: [FormError!]
  message: String!
  success: Boolean!
}

type UpdateDailyRecapAnswer {
  dailyRecapAnswer: DailyRecapAnswer
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateDailyRecapAnswerInput {
  answer: String
  id: ID!
  lang: GenericScalar
  type: String
}

type UpdateDailyRecapQuestion {
  dailyRecapQuestion: ThirdPartyDailyRecapQuestion
  errors: [FormError!]
  message: String!
  success: Boolean!
}

input UpdateDailyRecapQuestionInput {
  answers: [ID]
  id: ID!
  imageUrl: String
  lang: GenericScalar
  program: ID
  question: String
}

type UpdateHydration {
  message: String
  success: Boolean
}

type UpdateJourneyStatus {
  message: String
  success: Boolean
}

type UpdateLabTestReport {
  message: String!
  report: LabTestReport
  success: Boolean!
}

input UpdateMPSettingsInput {
  calories: Int
  carbs: Int
  fat: Int
  format: [MealTime!]
  omega3: Float
  protein: Int
}

type UpdateMealLogMutation {
  success: Boolean
}

type UpdateMealPlanSettings {
  message: String!
  success: Boolean!
}

type UpdateMealPlanTemplate {
  mealPlan: MealPlanTemplate
  message: String!
  success: Boolean!
}

type UpdateMyBrandedFood {
  message: String!
  success: Boolean!
}

input UpdateMyBrandedFoodInput {
  brandName: String
  brandOwner: String
  brandedFoodCategory: String
  description: String
  gtinUpc: String
  householdServingFulltext: String
  name: String
  nutrients: [NutrientInput]
  servingSize: Float
  servingSizeUnit: String
}

type UpdateMyChecklistItem {
  message: String!
  myChecklistItem: MyChecklistItem
  success: Boolean!
}

type UpdateMyCommonFood {
  message: String!
  success: Boolean!
}

input UpdateMyCommonFoodInput {
  description: String
  name: String
  nutrients: [NutrientInput]
  portions: [PortionInput]
}

type UpdateMyRecipe {
  message: String!
  recipe: UserRecipe
  success: Boolean!
}

input UpdateMyRecipeInput {
  courses: [String!]
  cuisines: [String!]
  ingredientLines: [String!]
  ingredients: [IngredientAmount!]
  instructions: [String!]
  language: Language
  mainImage: String
  mealTimes: [MealTime!]
  name: String
  numberOfServings: Int
  squareImage: String
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
}

type UpdateNote {
  errors: [FormError!]
  message: String!
  note: Note
  success: Boolean!
}

type UpdateOwnMealMutation {
  message: String
  success: Boolean
}

type UpdateOwnRecipe {
  message: String!
  success: Boolean!
}

type UpdateProfile {
  errors: [ErrorType]
  success: Boolean
}

type UpdateProfileBiomarkers {
  success: Boolean
}

type UpdateProtocol {
  message: String!
  protocol: Protocol
  success: Boolean!
}

input UpdateProtocolInput {
  group: ProtocolGroup
  id: ID!
  isActive: Boolean
}

type UpdateQuestion {
  errors: [FormError!]
  message: String!
  question: AssessmentQuestion
  success: Boolean!
}

input UpdateQuestionInput {
  answers: [CreateAnswerInput!]
  assessmentId: ID
  canSkip: Boolean
  helpText: String
  id: ID!
  information: String
  isFinalQuestion: Boolean
  isInitialQuestion: Boolean
  nextQuestionId: ID
  profileField: ProfileField
  questionType: QuestionType
  text: String
}

input UpdateSPInput {
  coach: ID
  exercise: String
  id: ID!
  isActive: Boolean
  name: String
  nutrition: String
  overview: String
  resources: String
  setProtocols: [SPProtocolInput!]
  setSupplements: [SingleSupplementActivableProtocolInput!]
  startDate: Date
  updateProtocols: [SPUpdateProtocolInput!]
  visibility: Boolean
}

type UpdateShoppingListRecipeServings {
  success: Boolean
}

type UpdateSubscription {
  message: String
  success: Boolean
}

type UpdateSupplement {
  message: String!
  success: Boolean!
  supplement: Supplement
}

input UpdateSupplementInput {
  brand: String
  category: String
  description: String
  directionsOfUse: [DirectionsOfUseInput!]
  directionsOfUseText: String
  externalId: String
  id: ID!
  images: [String!]
  ingredients: String
  instructions: String
  mainImage: String
  name: String
  servingName: String
  shopifyParentId: String
  shopifyVariantId: String
  sizeCount: Int
  sku: String
  storeId: String
  supplementFacts: String
}

type UpdateSupplementPlan {
  message: String!
  success: Boolean!
  supplementPlan: SupplementPlan
}

type UpdateSupplementRecommended {
  errors: [FormError!]
  message: String!
  success: Boolean!
  supplementRecommended: SupplementRecommended
}

input UpdateSupplementRecommendedInput {
  biomarkerId: ID
  id: ID!
  normalValues: [GenericScalar!]
  range: BiomarkerRangeInput
  supplementId: ID
}

type UpdateThirdPartyTrackerComponent {
  enabledComponents: [TrackerComponent!]
  message: String!
  success: Boolean!
}

input UpdateThirdPartyTrackerComponentInput {
  components: [TrackerComponent!]!
  operation: Operation!
}

type UpdateUserAssessmentScore {
  errors: [FormError!]
  message: String!
  success: Boolean!
  userProgress: UserProgress
}

input UpdateUserAssessmentScoreInput {
  assessmentId: ID!
  profileId: ID!
  score: Int
}

type UpdateUserProgram {
  message: String
  success: Boolean
}

type UpdateUserProgress {
  errors: [FormError!]
  message: String!
  success: Boolean!
  userProgress: UserProgress
}

input UpdateUserProgressInput {
  id: ID!
  score: Int
}

scalar Upload

type UsdaFood implements Node {
  commonNames: [String]
  dataType: String
  description: String
  foodDataId: String
  id: ID!
  nutrients: [Nutrients]
  portions: [Portion]
}

type User implements Node {
  appleUserSource: String
  appleUserSourceJson: JSONString
  avatar: String
  createdAt: DateTime!
  databaseId: String
  email: String
  id: ID!
  isActive: Boolean!
  isArUser: Boolean!
  name: String
  organizationId: UUID
  phone: String!
  profileId: String
  subscription: SubscriptionType
  updatedAt: DateTime!
  userSource: String
}

type UserAnswer implements Node {
  answer: AssessmentAnswer
  answerText: String
  createdAt: DateTime!
  id: ID!
  question: AssessmentQuestion!
  updatedAt: DateTime!
}

input UserAnswerInput {
  answerId: ID
  answerText: String
  questionId: ID!
}

input UserAssessmentsFilterInput {
  description: String
  status: AssessmentStatus
  title: String
}

type UserConnection {
  edges: [UserEdge]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User
}

type UserFavoriteMenuItem {
  isUserFavorite: Boolean
  success: Boolean
}

type UserFavoriteRecipe {
  isUserFavorite: Boolean
  message: String!
  success: Boolean
}

type UserFavoriteRestaurant {
  isUserFavorite: Boolean
  success: Boolean
}

type UserProgress implements Node {
  assessment: Assessment!
  createdAt: DateTime!
  currentQuestion: AssessmentQuestion!
  endDate: DateTime!
  id: ID!
  profile: ProfileType!
  score: Float
  startDate: DateTime!
  updatedAt: DateTime!
}

type UserProgressConnection {
  edges: [UserProgressEdge]!
  pageInfo: PageInfo!
}

type UserProgressEdge {
  cursor: String!
  node: UserProgress
}

type UserPurchases {
  activeSubscriptionTransaction: SubscriptionTransaction
}

type UserRecipe implements Node {
  courses: [String!]!
  cuisines: [String!]!
  id: ID!
  ingredientLines: [String!]!
  ingredients: [IngredientFoodFormat!]!
  instructions: String
  language: Language!
  mainImage: String
  mealTimes: [RecipeMealTime!]!
  name: String!
  numberOfServings: Int!
  nutrients: [Nutrient!]
  nutrientsPerServing: [Nutrient!]
  servingWeight: Float!
  squareImage: String
  tags: [String]
  text: String
  totalTime: String
  totalTimeInSeconds: Int
  weightInGrams: Float!
}

type UserRecipeConnection {
  count: Int
  edges: [UserRecipeEdge]!
  pageInfo: PageInfo!
}

type UserRecipeEdge {
  cursor: String!
  node: UserRecipe
}

type UserRecipeProxy {
  userRecipe: UserRecipe!
}

input UsersProgressFilterInput {
  assessmentId: ID
  currentQuestionId: ID
  profileId: ID
  scoreRange: RangeOperator
}

enum VideoZoomRole {
  HOST
  PARTICIPANT
}

enum WeeklyWeightGoal {
  GOAL_0_5
  GOAL_1
  GOAL_1_0
  GOAL_1_5
  GOAL_2
  GOAL_2_0
  GOAL_3
  GOAL_4
  MAINTAIN
  MANTAIN
}

input WeightEntryInput {
  date: Date!
  source: SourceType
  value: PositiveFloat!
}

type WeightTracker {
  entries: [Entry]
  latestEntry: DateTime
  start: Float
  tendency: Tendency
  today: Float
}